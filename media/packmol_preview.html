<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Packmol 3D Preview</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #1e1e1e;
        color: #cccccc;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #canvas-container {
        width: 100%;
        height: 100%;
      }

      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(30, 30, 30, 0.95);
        padding: 0;
        border-radius: 8px;
        max-width: 280px;
        min-width: 200px;
        max-height: calc(100vh - 40px);
        overflow: visible;
        border: 1px solid #555;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      }

      #controls.dragging {
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        transform: scale(1.02);
      }

      .controls-header {
        background: rgba(0, 102, 204, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 8px 8px 0 0;
        cursor: move;
        display: flex;
        justify-content: space-between;
        align-items: center;
        -webkit-user-select: none;
        user-select: none;
        font-weight: bold;
        font-size: 13px;
      }

      .controls-header:hover {
        background: rgba(0, 82, 163, 0.9);
      }

      .controls-content {
        padding: 10px;
        max-height: calc(100vh - 100px);
        overflow-y: auto;
      }

      .controls-toggle {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        padding: 0;
        width: 20px;
        height: 20px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
      }

      .controls-toggle:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      #controls.collapsed .controls-content {
        display: none;
      }

      #controls.collapsed {
        border-radius: 8px;
      }

      .control-group {
        margin-bottom: 15px;
        border: 1px solid transparent;
        border-radius: 6px;
        transition: all 0.3s ease;
      }

      .control-group:hover {
        border-color: #444;
        background: rgba(255, 255, 255, 0.02);
      }

      .control-group-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        -webkit-user-select: none;
        user-select: none;
        padding: 4px 8px;
        border-radius: 4px;
        transition: background-color 0.2s;
      }

      .control-group-header:hover {
        background: rgba(255, 255, 255, 0.05);
      }

      .control-group h3 {
        margin: 0;
        font-size: 14px;
        color: #ffffff;
        flex: 1;
        padding-bottom: 0;
        border-bottom: none;
      }

      .control-group-toggle {
        background: none;
        border: none;
        color: #ccc;
        font-size: 12px;
        cursor: pointer;
        padding: 2px 4px;
        border-radius: 3px;
        transition: all 0.2s;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .control-group-toggle:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      .control-group-content {
        margin-top: 8px;
        padding-left: 4px;
        border-left: 2px solid #444;
        margin-left: 4px;
        transition: all 0.3s ease;
        overflow: hidden;
      }

      .control-group.collapsed .control-group-content {
        max-height: 0;
        margin-top: 0;
        opacity: 0;
        transform: translateY(-10px);
      }

      .control-group:not(.collapsed) .control-group-content {
        max-height: 1000px;
        opacity: 1;
        transform: translateY(0);
      }

      .structure-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        font-size: 12px;
        padding: 2px 0;
      }

      .structure-checkbox {
        margin-right: 8px;
        flex-shrink: 0;
      }

      .structure-info {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .structure-count {
        color: #888;
        margin-left: 5px;
      }

      .structure-color-picker {
        width: 20px;
        height: 20px;
        border: 1px solid #555;
        border-radius: 3px;
        cursor: pointer;
        margin-left: 8px;
        flex-shrink: 0;
      }

      .structure-color-picker::-webkit-color-swatch {
        border: none;
        border-radius: 2px;
      }

      .structure-color-picker::-webkit-color-swatch-wrapper {
        padding: 0;
      }

      .button {
        background: #0066cc;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin: 2px;
        transition: all 0.2s ease;
        white-space: nowrap;
        flex-shrink: 0;
      }

      .button:hover {
        background: #0052a3;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 102, 204, 0.3);
      }

      .button:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 102, 204, 0.3);
      }

      /* 折叠状态下的控制面板优化 */
      #controls.collapsed {
        min-width: auto;
        width: auto;
      }

      #controls.collapsed .controls-header {
        border-radius: 8px;
        padding: 6px 10px;
      }

      /* 响应式设计 - 小屏幕优化 */
      @media (max-width: 768px) {
        #controls {
          max-width: calc(100vw - 20px);
          font-size: 11px;
        }
        
        .button {
          padding: 4px 8px;
          font-size: 11px;
          margin: 1px;
        }
        
        .controls-header {
          padding: 6px 8px;
          font-size: 12px;
        }
        
        .control-group h3 {
          font-size: 13px;
        }
      }

      /* 拖拽时的视觉反馈增强 */
      #controls.dragging {
        transition: none;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.6);
        transform: scale(1.02) rotate(1deg);
        z-index: 1000;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #cccccc;
        font-size: 16px;
      }

      .error {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ff6b6b;
        font-size: 14px;
        text-align: center;
        max-width: 300px;
      }

      #info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(30, 30, 30, 0.9);
        padding: 8px;
        border-radius: 3px;
        font-size: 11px;
        color: #aaa;
      }

      .surface-slider-container {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 2px 0;
      }

      .surface-slider {
        width: 100px;
        height: 18px;
        background: #444;
        border-radius: 9px;
        outline: none;
        cursor: pointer;
      }

      .surface-slider::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #0066cc;
        cursor: pointer;
        border: 2px solid #ffffff;
      }

      .surface-slider::-webkit-slider-thumb:hover {
        background: #0052a3;
      }

      .surface-slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #0066cc;
        cursor: pointer;
        border: 2px solid #ffffff;
      }

      /* 设置面板样式 */
      .settings-panel {
        display: none;
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 101;
        background: rgba(30, 30, 30, 0.95);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #555;
        min-width: 280px;
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .settings-panel.visible {
        display: block;
      }

      .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 1px solid #444;
      }

      .settings-title {
        font-size: 16px;
        font-weight: bold;
        color: #ffffff;
      }

      .close-settings {
        background: #666;
        color: white;
        border: none;
        padding: 4px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
      }

      .close-settings:hover {
        background: #888;
      }

      .settings-button {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        background: rgba(0, 102, 204, 0.9);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
      }

      .settings-button:hover {
        background: rgba(0, 82, 163, 0.9);
      }

      .setting-item {
        margin-bottom: 15px;
      }

      .setting-label {
        display: block;
        margin-bottom: 5px;
        font-size: 13px;
        color: #ccc;
        font-weight: 500;
      }

      .setting-input {
        width: 100%;
        padding: 6px 8px;
        background: #2a2a2a;
        border: 1px solid #555;
        border-radius: 4px;
        color: #fff;
        font-size: 12px;
      }

      .setting-input:focus {
        outline: none;
        border-color: #0066cc;
      }

      .setting-slider {
        width: 100%;
        height: 20px;
        background: #444;
        border-radius: 10px;
        outline: none;
        cursor: pointer;
      }

      .setting-slider::-webkit-slider-thumb {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0066cc;
        cursor: pointer;
        border: 2px solid #ffffff;
      }

      .setting-slider::-webkit-slider-thumb:hover {
        background: #0052a3;
      }

      .setting-value {
        display: inline-block;
        margin-left: 8px;
        font-size: 11px;
        color: #aaa;
        min-width: 30px;
      }

      .theme-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-top: 5px;
      }

      .theme-option {
        padding: 8px;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 6px;
        cursor: pointer;
        text-align: center;
        font-size: 11px;
        color: #ccc;
        transition: all 0.2s;
      }

      .theme-option.active {
        border-color: #0066cc;
        background: #0066cc20;
        color: #fff;
      }

      .theme-option:hover {
        border-color: #666;
        background: #333;
      }

      .theme-colors {
        display: flex;
        justify-content: center;
        gap: 2px;
        margin-top: 4px;
      }

      .theme-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
        border: 1px solid #555;
      }

      .color-preset-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 4px;
        margin-top: 5px;
      }

      .color-preset {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        cursor: pointer;
        border: 2px solid transparent;
        transition: border-color 0.2s;
      }

      .color-preset:hover {
        border-color: #666;
      }

      .color-preset.active {
        border-color: #0066cc;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="canvas-container"></div>

      <div id="controls">
        <div class="controls-header" id="controls-header">
          <div>🎛️ Control Panel</div>
          <button class="controls-toggle" onclick="toggleControlsPanel()" title="折叠/展开面板">
            <span id="controls-toggle-icon">−</span>
          </button>
        </div>
        <div class="controls-content">
          <div class="control-group">
            <div class="control-group-header" onclick="toggleControlGroup(this)">
              <h3>🎮 View Controls</h3>
              <button class="control-group-toggle" title="折叠/展开">
                <span>−</span>
              </button>
            </div>
            <div class="control-group-content">
              <button class="button" onclick="resetCamera()">Reset Camera</button>
              <button class="button" onclick="toggleWireframe()">
                Toggle Wireframe
              </button>
              <button class="button" onclick="toggleMultisphere()">
                Toggle Multisphere
              </button>
              <button class="button" onclick="toggleSurfaceArrows()">
                Toggle Surface Arrows
              </button>
              <button class="button" onclick="randomizeColors()">
                Random Colors
              </button>
              <button class="button" onclick="resetColors()">Reset Colors</button>
            </div>
          </div>

          <div class="control-group">
            <div class="control-group-header" onclick="toggleControlGroup(this)">
              <h3>📦 Structures & Constraints</h3>
              <button class="control-group-toggle" title="折叠/展开">
                <span>−</span>
              </button>
            </div>
            <div class="control-group-content">
              <div id="structure-list"></div>
            </div>
          </div>

          <div class="control-group">
            <div class="control-group-header" onclick="toggleControlGroup(this)">
              <h3>📊 Statistics</h3>
              <button class="control-group-toggle" title="折叠/展开">
                <span>−</span>
              </button>
            </div>
            <div class="control-group-content">
              <div id="constraint-list"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- 设置按钮 -->
      <button class="settings-button" onclick="toggleSettings()">⚙️ Settings</button>

      <!-- 设置面板 -->
      <div id="settings-panel" class="settings-panel">
        <div class="settings-header">
          <div class="settings-title">⚙️ 可视化设置</div>
          <button class="close-settings" onclick="toggleSettings()">✕</button>
        </div>

        <!-- 颜色主题 -->
        <div class="setting-item">
          <label class="setting-label">🎨 颜色主题</label>
          <div class="theme-grid" id="theme-grid">
            <!-- 主题选项将通过 JavaScript 动态生成 -->
          </div>
        </div>

        <!-- 几何体分段数设置 -->
        <div class="setting-item">
          <label class="setting-label">🔗 连线密度</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="segments-slider" 
                   min="8" max="64" step="2" value="16" 
                   oninput="updateGeometrySegments(this.value)">
            <span class="setting-value" id="segments-value">16</span>
          </div>
          <div style="font-size: 10px; color: #888; margin-top: 2px;">
            调整几何体的分段数，数值越大连线越密集
          </div>
        </div>

        <!-- 透明度设置 -->
        <div class="setting-item">
          <label class="setting-label">🔍 结构透明度</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="opacity-slider" 
                   min="0.1" max="1.0" step="0.05" value="0.6" 
                   oninput="updateOpacity(this.value)">
            <span class="setting-value" id="opacity-value">0.60</span>
          </div>
        </div>

        <!-- 约束透明度设置 -->
        <div class="setting-item">
          <label class="setting-label">📐 约束透明度</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="constraint-opacity-slider" 
                   min="0.1" max="1.0" step="0.05" value="0.3" 
                   oninput="updateConstraintOpacity(this.value)">
            <span class="setting-value" id="constraint-opacity-value">0.30</span>
          </div>
        </div>

        <!-- 背景颜色 -->
        <div class="setting-item">
          <label class="setting-label">🌌 背景颜色</label>
          <div class="color-preset-grid" id="background-presets">
            <!-- 背景色预设将通过 JavaScript 动态生成 -->
          </div>
          <input type="color" class="setting-input" id="background-color" 
                 value="#1e1e1e" onchange="updateBackgroundColor(this.value)"
                 style="margin-top: 8px; height: 32px;">
        </div>

        <!-- 光照强度 -->
        <div class="setting-item">
          <label class="setting-label">💡 环境光强度</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="ambient-light-slider" 
                   min="0.1" max="1.5" step="0.1" value="0.6" 
                   oninput="updateAmbientLight(this.value)">
            <span class="setting-value" id="ambient-light-value">0.6</span>
          </div>
        </div>

        <!-- 方向光强度 -->
        <div class="setting-item">
          <label class="setting-label">🔆 方向光强度</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="directional-light-slider" 
                   min="0.1" max="2.0" step="0.1" value="0.8" 
                   oninput="updateDirectionalLight(this.value)">
            <span class="setting-value" id="directional-light-value">0.8</span>
          </div>
        </div>

        <!-- 重置按钮 -->
        <div class="setting-item">
          <button class="button" onclick="resetSettings()" style="width: 100%;">
            🔄 重置所有设置
          </button>
        </div>

        <!-- 保存/加载设置 -->
        <div class="setting-item">
          <div style="display: flex; gap: 8px;">
            <button class="button" onclick="saveSettings()" style="flex: 1;">
              💾 保存设置
            </button>
            <button class="button" onclick="loadSettings()" style="flex: 1;">
              📁 加载设置
            </button>
          </div>
        </div>
      </div>

      <div id="info">Mouse: Left=Rotate, Right=Pan, Wheel=Zoom</div>

      <div id="loading" class="loading">Loading...</div>
    </div>

    <script>
      console.log('🚀 Webview script starting...');

      // 全局变量
      let scene, camera, renderer, controls;
      let structureGroups = new Map();
      let constraintGroups = new Map();
      let currentData = null;
      let wireframeMode = false;
      let isThreeJSReady = false;
      let initializationAttempts = 0;
      const MAX_INIT_ATTEMPTS = 20;
      // 存储表面约束的大小参数
      let surfaceConstraintSizes = new Map();
      
      // 控制面板相关变量
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let controlPanelState = {
        collapsed: false,
        position: { x: 10, y: 10 },
        groupStates: {
          'view-controls': false,
          'structures-constraints': false,
          'statistics': false
        }
      };
      
      // 设置相关全局变量
      let ambientLight, directionalLight;
      let currentSettings = {
        geometrySegments: 16,  // 几何体分段数（控制连线数量）
        structureOpacity: 0.6,
        constraintOpacity: 0.3,
        backgroundColor: '#1e1e1e',
        ambientLightIntensity: 0.6,
        directionalLightIntensity: 0.8,
        colorTheme: 'default'
      };

      // 颜色主题定义
      const colorThemes = {
        'default': {
          name: '默认',
          colors: [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeaa7, 0xdda0dd, 0x74b9ff, 0xfd79a8, 0xa29bfe, 0x6c5ce7]
        },
        'warm': {
          name: '暖色调',
          colors: [0xff7675, 0xfd79a8, 0xe17055, 0xf39c12, 0xe74c3c, 0x9b59b6, 0x8e44ad, 0x3f3f3f, 0x34495e, 0x2c3e50]
        },
        'cool': {
          name: '冷色调',
          colors: [0x00b894, 0x00cec9, 0x0984e3, 0x74b9ff, 0x6c5ce7, 0xa29bfe, 0x81ecec, 0x55a3ff, 0x2d3436, 0x636e72]
        },
        'pastel': {
          name: '柔和色',
          colors: [0xfab1a0, 0xffeaa7, 0xbadc58, 0x6c5ce7, 0xa29bfe, 0xfd79a8, 0x74b9ff, 0x00b894, 0xe17055, 0x636e72]
        },
        'monochrome': {
          name: '单色调',
          colors: [0xffffff, 0xe6e6e6, 0xcccccc, 0xb3b3b3, 0x999999, 0x808080, 0x666666, 0x4d4d4d, 0x333333, 0x1a1a1a]
        },
        'vibrant': {
          name: '鲜艳色',
          colors: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8000, 0x8000ff, 0x00ff80, 0xff0080]
        }
      };

      // 背景色预设
      const backgroundPresets = [
        { name: '深灰', color: '#1e1e1e' },
        { name: '黑色', color: '#000000' },
        { name: '深蓝', color: '#0f1419' },
        { name: '白色', color: '#ffffff' },
        { name: '浅灰', color: '#f5f5f5' }
      ];

      // VS Code API
      let vscode;
      try {
          vscode = acquireVsCodeApi();
          console.log('✅ VS Code API acquired successfully');
      } catch (error) {
          console.error('❌ Failed to acquire VS Code API:', error);
          document.getElementById('loading').innerHTML = 'Error: Cannot acquire VS Code API';
      }

      // 立即尝试发送一个测试消息来验证连接
      function testVSCodeConnection() {
          console.log('🧪 Testing VS Code connection...');
          if (vscode) {
              try {
                  vscode.postMessage({ type: 'test', message: 'Webview loaded' });
                  console.log('✅ Test message sent successfully');
              } catch (error) {
                  console.error('❌ Failed to send test message:', error);
              }
          }
      }

      // 在没有 Three.js 的情况下也要发送 ready 消息
      function sendReadyMessage() {
          console.log('📤 Sending ready message to VS Code...');
          if (vscode) {
              try {
                  vscode.postMessage({ type: 'ready' });
                  console.log('✅ Ready message sent successfully');
                  document.getElementById('loading').innerHTML = 'Ready! Waiting for data...';
              } catch (error) {
                  console.error('❌ Failed to send ready message:', error);
                  document.getElementById('loading').innerHTML = 'Error sending ready message';
              }
          } else {
              console.error('❌ Cannot send ready message - vscode API not available');
              document.getElementById('loading').innerHTML = 'Error: VS Code API not available';
          }
      }

      // 检查 Three.js 是否加载
      function checkThreeJS() {
          initializationAttempts++;
          console.log(`🔍 Checking Three.js (attempt ${initializationAttempts}/${MAX_INIT_ATTEMPTS})...`);

          if (typeof THREE !== 'undefined') {
              console.log('✅ Three.js loaded successfully');
              initThreeJS();
          } else if (initializationAttempts < MAX_INIT_ATTEMPTS) {
              console.log('⏳ Three.js not yet loaded, retrying in 200ms...');
              setTimeout(checkThreeJS, 200);
          } else {
              console.error('❌ Three.js failed to load after maximum attempts');
              document.getElementById('loading').innerHTML = 'Error: Three.js failed to load. Using fallback mode.';
              // 即使 Three.js 失败，也要发送 ready 消息
              sendReadyMessage();
          }
      }

      // 初始化 Three.js 场景
      function initThreeJS() {
          console.log('🎨 Initializing Three.js...');
          const container = document.getElementById('canvas-container');

          if (!container) {
              console.error('❌ Canvas container not found');
              document.getElementById('loading').innerHTML = 'Error: Canvas container not found';
              return;
          }

          try {
              // 场景
              scene = new THREE.Scene();
              scene.background = new THREE.Color(currentSettings.backgroundColor);
              console.log('✅ Scene created');

              // 相机
              const aspect = container.clientWidth / container.clientHeight || 1;
              camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
              camera.position.set(50, 50, 50);
              camera.lookAt(0, 0, 0);
              console.log('✅ Camera created');

              // 渲染器
              renderer = new THREE.WebGLRenderer({ antialias: true });
              renderer.setSize(container.clientWidth || 400, container.clientHeight || 300);
              renderer.shadowMap.enabled = true;
              renderer.shadowMap.type = THREE.PCFSoftShadowMap;
              container.appendChild(renderer.domElement);
              console.log('✅ Renderer created and added to DOM');

              // 控制器 (简化版本，不依赖 OrbitControls)
              setupSimpleControls();
              console.log('✅ Controls setup complete');

              // 光照
              ambientLight = new THREE.AmbientLight(0x404040, currentSettings.ambientLightIntensity);
              scene.add(ambientLight);

              directionalLight = new THREE.DirectionalLight(0xffffff, currentSettings.directionalLightIntensity);
              directionalLight.position.set(100, 100, 50);
              directionalLight.castShadow = true;
              directionalLight.shadow.mapSize.width = 2048;
              directionalLight.shadow.mapSize.height = 2048;
              scene.add(directionalLight);
              console.log('✅ Lights added');

              // 坐标轴
              const axesHelper = new THREE.AxesHelper(10);
              scene.add(axesHelper);

              // 渲染循环
              animate();
              console.log('✅ Animation loop started');

              // 窗口调整
              window.addEventListener('resize', onWindowResize);
              console.log('✅ Resize listener added');

              // 标记为准备就绪
              isThreeJSReady = true;
              console.log('🎉 Three.js initialization complete!');

              // 初始化设置界面
              initializeSettings();

              // 初始化控制面板功能
              loadControlPanelState();
              initializeControlsDrag();

              // 发送准备就绪消息
              sendReadyMessage();

              // 隐藏加载指示器
              document.getElementById('loading').style.display = 'none';

          } catch (error) {
              console.error('❌ Error initializing Three.js:', error);
              document.getElementById('loading').innerHTML = 'Error initializing 3D scene: ' + error.message;
              // 即使初始化失败，也要发送 ready 消息
              sendReadyMessage();
          }
      }

      // 简单的鼠标控制
      function setupSimpleControls() {
          let isMouseDown = false;
          let mouseButton = -1;
          let mouseX = 0, mouseY = 0;

          renderer.domElement.addEventListener('mousedown', (event) => {
              isMouseDown = true;
              mouseButton = event.button;
              mouseX = event.clientX;
              mouseY = event.clientY;
          });

          renderer.domElement.addEventListener('mouseup', () => {
              isMouseDown = false;
          });

          renderer.domElement.addEventListener('mousemove', (event) => {
              if (!isMouseDown) return;

              const deltaX = event.clientX - mouseX;
              const deltaY = event.clientY - mouseY;

              if (mouseButton === 0) { // 左键旋转
                  const spherical = new THREE.Spherical();
                  spherical.setFromVector3(camera.position);
                  spherical.theta -= deltaX * 0.01;
                  spherical.phi += deltaY * 0.01;
                  spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                  camera.position.setFromSpherical(spherical);
                  camera.lookAt(0, 0, 0);
              } else if (mouseButton === 2) { // 右键平移
                  const panSpeed = 0.1;
                  camera.position.x += deltaX * panSpeed;
                  camera.position.y -= deltaY * panSpeed;
              }

              mouseX = event.clientX;
              mouseY = event.clientY;
          });

          renderer.domElement.addEventListener('wheel', (event) => {
              const zoomSpeed = 0.1;
              const direction = camera.position.clone().normalize();
              if (event.deltaY > 0) {
                  camera.position.add(direction.multiplyScalar(zoomSpeed * camera.position.length()));
              } else {
                  camera.position.sub(direction.multiplyScalar(zoomSpeed * camera.position.length()));
              }
          });

          renderer.domElement.addEventListener('contextmenu', (event) => {
              event.preventDefault();
          });
      }

      // 窗口大小调整
      function onWindowResize() {
          const container = document.getElementById('canvas-container');
          camera.aspect = container.clientWidth / container.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(container.clientWidth, container.clientHeight);
      }

      // 动画循环
      function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
      }

      // 更新数据
      function updateData(data) {
          console.log('🔄 === updateData START ===');
          console.log('Input data:', data);
          console.log('Three.js ready:', isThreeJSReady);
          console.log('Scene exists:', !!scene);
          console.log('Camera exists:', !!camera);

          if (!isThreeJSReady) {
              console.error('❌ Three.js not ready for updateData');
              alert('Three.js 未准备好，无法更新数据');
              return;
          }

          try {
              currentData = data;
              
              // 如果收到了配置数据，应用它们
              if (data.settings) {
                  console.log('📝 Applying settings from extension:', data.settings);
                  applySettingsFromExtension(data.settings);
              }
                   // 清除现有的结构
          console.log('🧹 Clearing existing structures...');
          console.log('Structure groups count:', structureGroups.size);
          console.log('Constraint groups count:', constraintGroups.size);

          structureGroups.forEach(group => {
              console.log('Removing group:', group.name);
              scene.remove(group);
          });
          structureGroups.clear();
          constraintGroups.clear(); // 约束现在是结构的子对象，会随结构一起删除

              // 创建结构
              if (data.input && data.input.structures) {
                  console.log('🏗️ Creating structures for:', data.input.structures.length, 'structures');

                  // 检查多球数据
                  const multisphereStructures = data.input.structures.filter(s =>
                      s.visualInfo && s.visualInfo.geometry && s.visualInfo.geometry.type === 'multi_sphere'
                  );
                  console.log('🔮 Found', multisphereStructures.length, 'structures with multisphere geometry');

                  multisphereStructures.forEach((structure, i) => {
                      const sphereCount = structure.visualInfo.geometry.spheres?.length || 0;
                      console.log('🔮 Multisphere structure', i + 1, ':', structure.filename, 'with', sphereCount, 'spheres');
                      if (structure.visualInfo.geometry.spheres) {
                          structure.visualInfo.geometry.spheres.forEach((sphere, j) => {
                              console.log('  Sphere', j + 1, ':', sphere.center, 'radius=', sphere.radius);
                          });
                      }
                  });

                  data.input.structures.forEach((structure, index) => {
                      console.log('📦 Creating structure ' + index + ':', structure.filename, 'number=' + structure.number);

                      // 详细检查结构的可视化信息
                      if (structure.visualInfo) {
                          console.log('  📊 VisualInfo type:', structure.visualInfo.type);
                          if (structure.visualInfo.geometry) {
                              console.log('  🔮 Geometry type:', structure.visualInfo.geometry.type);
                              if (structure.visualInfo.geometry.type === 'multi_sphere') {
                                  console.log('  🎯 MULTISPHERE DETECTED! Spheres:', structure.visualInfo.geometry.spheres?.length || 0);
                              }
                          }
                      } else {
                          console.warn('  ❌ No visualInfo found for structure:', structure.filename);
                      }

                      try {
                          createStructureVisualization(structure);
                          console.log('✅ Structure ' + index + ' created successfully');
                      } catch (structError) {
                          console.error('❌ Error creating structure ' + index + ':', structError);
                      }
                  });
              } else {
                  console.warn('⚠️ No structures found in data');
                  console.log('Data.input:', data.input);
              }

              // 更新控制面板
              console.log('🎛️ Updating control panel...');
              updateControlPanel();

              // 调整相机位置
              console.log('📷 Fitting camera to scene...');
              fitCameraToScene();

              console.log('✅ === updateData COMPLETE ===');
              // alert('数据更新完成！结构数量: ' + (data.input?.structures?.length || 0));

          } catch (error) {
              console.error('❌ === updateData ERROR ===');
              console.error('Error details:', error);
              // alert('updateData 出错: ' + error.message);
          }
      }

      // 创建多球拟合可视化
      function createMultisphereVisualization(structure, group) {
          console.log('Creating multisphere visualization for:', structure.id);

          // 检查是否有多球几何体数据
          if (structure.visualInfo && structure.visualInfo.geometry &&
              structure.visualInfo.geometry.type === 'multi_sphere' &&
              structure.visualInfo.geometry.spheres) {

              const spheres = structure.visualInfo.geometry.spheres;
              console.log('Creating ' + spheres.length + ' spheres for structure:', structure.id);

              const structureColor = getStructureColor(structure.id);

              // 创建每个球体
              spheres.forEach((sphere, index) => {
                  const sphereGeometry = new THREE.SphereGeometry(sphere.radius, currentSettings.geometrySegments, currentSettings.geometrySegments);

                  // 为不同的球体使用略微不同的颜色
                  const color = new THREE.Color(structureColor);
                  const hsl = {};
                  color.getHSL(hsl);

                  // 调整色调和饱和度来区分不同的球体
                  hsl.h = (hsl.h + index * 0.1) % 1.0;
                  hsl.s = Math.min(1.0, hsl.s + index * 0.05);
                  color.setHSL(hsl.h, hsl.s, hsl.l);

                  const sphereMaterial = new THREE.MeshLambertMaterial({
                      color: color,
                      transparent: true,
                      opacity: currentSettings.structureOpacity,
                      wireframe: false
                  });

                  const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                  sphereMesh.position.set(sphere.center[0], sphere.center[1], sphere.center[2]);
                  sphereMesh.name = structure.id + '_multisphere_' + index;

                  // 添加球体边框（线框）
                  const wireframeGeometry = new THREE.SphereGeometry(sphere.radius, Math.max(8, currentSettings.geometrySegments / 2), Math.max(8, currentSettings.geometrySegments / 2));
                  const wireframeMaterial = new THREE.MeshBasicMaterial({
                      color: structureColor,
                      wireframe: true,
                      transparent: true,
                      opacity: 0.4
                  });
                  const wireframeMesh = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
                  wireframeMesh.position.set(sphere.center[0], sphere.center[1], sphere.center[2]);
                  wireframeMesh.name = structure.id + '_multisphere_wireframe_' + index;

                  group.add(sphereMesh);
                  group.add(wireframeMesh);

                  console.log('Added sphere ' + index + ': center=(' + sphere.center.join(', ') + '), radius=' + sphere.radius.toFixed(2));
              });

              // 添加连接线来显示球体之间的关系
              if (spheres.length > 1) {
                  createSphereBonds(spheres, group, structureColor);
              }

              // 添加质心标记
              const centroid = calculateSphereCentroid(spheres);
              const centroidSegments = Math.max(6, Math.floor(currentSettings.geometrySegments / 3));
              const centroidGeometry = new THREE.SphereGeometry(0.8, centroidSegments, centroidSegments);
              const centroidMaterial = new THREE.MeshBasicMaterial({
                  color: structureColor,
                  transparent: true,
                  opacity: 0.9
              });
              const centroidMesh = new THREE.Mesh(centroidGeometry, centroidMaterial);
              centroidMesh.position.set(centroid[0], centroid[1], centroid[2]);
              centroidMesh.name = structure.id + '_centroid';
              group.add(centroidMesh);

              console.log('Multisphere visualization created with ' + spheres.length + ' spheres');
              return true;
          }

          return false;
      }

      // 创建球体之间的连接线
      function createSphereBonds(spheres, group, color) {
          const bondMaterial = new THREE.LineBasicMaterial({
              color: color,
              transparent: true,
              opacity: currentSettings.constraintOpacity
          });

          // 连接相近的球体
          for (let i = 0; i < spheres.length; i++) {
              for (let j = i + 1; j < spheres.length; j++) {
                  const sphere1 = spheres[i];
                  const sphere2 = spheres[j];

                  // 计算球体中心之间的距离
                  const distance = Math.sqrt(
                      Math.pow(sphere1.center[0] - sphere2.center[0], 2) +
                      Math.pow(sphere1.center[1] - sphere2.center[1], 2) +
                      Math.pow(sphere1.center[2] - sphere2.center[2], 2)
                  );

                  // 如果距离小于两个球体半径之和的1.5倍，则连接它们
                  const maxBondDistance = (sphere1.radius + sphere2.radius) * 1.5;
                  if (distance <= maxBondDistance) {
                      const bondGeometry = new THREE.BufferGeometry().setFromPoints([
                          new THREE.Vector3(sphere1.center[0], sphere1.center[1], sphere1.center[2]),
                          new THREE.Vector3(sphere2.center[0], sphere2.center[1], sphere2.center[2])
                      ]);

                      const bondLine = new THREE.Line(bondGeometry, bondMaterial);
                      bondLine.name = 'bond_' + i + '_' + j;
                      group.add(bondLine);
                  }
              }
          }
      }

      // 计算多球质心
      function calculateSphereCentroid(spheres) {
          const totalVolume = spheres.reduce((sum, sphere) =>
              sum + (4/3) * Math.PI * Math.pow(sphere.radius, 3), 0);

          let weightedX = 0, weightedY = 0, weightedZ = 0;

          spheres.forEach(sphere => {
              const volume = (4/3) * Math.PI * Math.pow(sphere.radius, 3);
              const weight = volume / totalVolume;

              weightedX += sphere.center[0] * weight;
              weightedY += sphere.center[1] * weight;
              weightedZ += sphere.center[2] * weight;
          });

          return [weightedX, weightedY, weightedZ];
      }

      // 创建结构可视化（支持多球拟合）
      function createStructureVisualization(structure) {
          console.log('🎨 === createStructureVisualization START ===');
          console.log('Structure ID:', structure.id);
          console.log('Structure filename:', structure.filename);
          console.log('Structure number:', structure.number);
          console.log('Has visualInfo:', !!structure.visualInfo);

          if (structure.visualInfo) {
              console.log('VisualInfo type:', structure.visualInfo.type);
              console.log('Has geometry:', !!structure.visualInfo.geometry);
              if (structure.visualInfo.geometry) {
                  console.log('Geometry type:', structure.visualInfo.geometry.type);
                  if (structure.visualInfo.geometry.type === 'multi_sphere') {
                      console.log('🔮 MULTISPHERE GEOMETRY FOUND!');
                      console.log('Number of spheres:', structure.visualInfo.geometry.spheres?.length || 0);
                  }
              }
          }

          try {
              const group = new THREE.Group();
              group.name = structure.id;
              console.log('✅ Created group for structure:', structure.id);

              // 检查是否为单分子结构且有多球拟合数据
              const isMultisphereStructure = structure.number === 1 &&
                  structure.visualInfo &&
                  structure.visualInfo.geometry &&
                  structure.visualInfo.geometry.type === 'multi_sphere';

              console.log('Is multisphere structure:', isMultisphereStructure);

              if (isMultisphereStructure) {
                  console.log('🔮 Creating multisphere representation for single molecule:', structure.id);

                  // 创建多球拟合可视化
                  const multisphereCreated = createMultisphereVisualization(structure, group);

                  if (multisphereCreated) {
                      console.log('✅ Multisphere representation created successfully');
                  } else {
                      console.warn('❌ Failed to create multisphere representation, falling back to default');
                  }
              } else {
                  console.log('📦 Not a multisphere structure, using default visualization');
              }

              // 处理约束（如果有）
              if (structure.constraints && structure.constraints.length > 0) {
                  console.log('Processing', structure.constraints.length, 'constraints for structure:', structure.id);

                  // 基于约束创建可视化，并添加到结构组中
                  structure.constraints.forEach((constraint, index) => {
                      console.log(`Creating constraint ${index}:`, constraint);
                      const constraintMesh = createConstraintVisualization(constraint, structure.id + '_constraint_' + index);
                      if (constraintMesh) {
                          console.log('Successfully created constraint mesh');
                          constraintGroups.set(structure.id + '_constraint_' + index, constraintMesh);
                          group.add(constraintMesh); // 添加到结构组而不是场景
                      } else {
                          console.warn('Failed to create constraint mesh');
                      }
                  });

              } else {
                  console.log('No constraints found, structure will be represented by constraints only');
              }

              // 添加到场景
              structureGroups.set(structure.id, group);
              scene.add(group);

              console.log('Successfully created and added structure group:', structure.id);
              console.log('Current scene children count:', scene.children.length);

          } catch (error) {
              console.error('Error in createStructureVisualization:', error);
          }
      }


      // 创建约束可视化
      function createConstraintVisualization(constraint, id) {
          console.log('Creating constraint visualization:', constraint, id);
          const geometry = getConstraintGeometry(constraint.geometry, id);
          if (!geometry) {
              console.log('No geometry created for constraint');
              return null;
          }

          // 从 id 中提取结构 ID (格式: structureId_constraint_index)
          const structureId = id.split('_constraint_')[0];
          const structureColor = getStructureColor(structureId);

          // 根据约束类型调整颜色
          let constraintColor = structureColor;
          if (constraint.type === 'outside') {
              // outside 约束使用稍微偏红的结构颜色
              const color = new THREE.Color(structureColor);
              color.r = Math.min(1.0, color.r + 0.2);
              constraintColor = color.getHex();
          } else {
              // inside 约束使用稍微偏绿的结构颜色
              const color = new THREE.Color(structureColor);
              color.g = Math.min(1.0, color.g + 0.2);
              constraintColor = color.getHex();
          }

          const material = new THREE.MeshLambertMaterial({
              color: constraintColor,
              transparent: true,
              opacity: currentSettings.constraintOpacity,
              wireframe: true
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.name = id;

          // 为表面约束（plane 和 xygauss）添加方向箭头
          if (constraint.geometry.type === 'plane' || constraint.geometry.type === 'xygauss') {
              const constraintGroup = new THREE.Group();
              constraintGroup.add(mesh);
              
              // 创建方向箭头
              const arrows = createSurfaceDirectionArrows(constraint, constraintColor, id);
              arrows.forEach(arrow => constraintGroup.add(arrow));
              
              constraintGroup.name = id;
              console.log('Created constraint group with surface arrows for:', constraint.geometry.type);
              return constraintGroup;
          }

          console.log('Created constraint mesh with color:', constraintColor.toString(16));
          return mesh;
      }

      // 计算场景的合理大小，用于确定表面约束的默认大小
      function calculateSceneSize() {
          if (!currentData || !currentData.input || !currentData.input.structures) {
              return 50; // 默认大小
          }

          let maxSize = 0;
          currentData.input.structures.forEach(structure => {
              if (structure.constraints) {
                  structure.constraints.forEach(constraint => {
                      switch (constraint.geometry.type) {
                          case 'sphere':
                              if (constraint.geometry.parameters.length >= 4) {
                                  const radius = constraint.geometry.parameters[3];
                                  maxSize = Math.max(maxSize, radius * 2);
                              }
                              break;
                          case 'box':
                              if (constraint.geometry.parameters.length >= 6) {
                                  const [x1, y1, z1, x2, y2, z2] = constraint.geometry.parameters;
                                  const size = Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1), Math.abs(z2 - z1));
                                  maxSize = Math.max(maxSize, size);
                              }
                              break;
                          case 'cube':
                              if (constraint.geometry.parameters.length >= 4) {
                                  const size = constraint.geometry.parameters[3];
                                  maxSize = Math.max(maxSize, size);
                              }
                              break;
                          case 'cylinder':
                              if (constraint.geometry.parameters.length >= 7) {
                                  const [x1, y1, z1, x2, y2, z2, radius] = constraint.geometry.parameters;
                                  const height = Math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2);
                                  maxSize = Math.max(maxSize, Math.max(radius * 2, height));
                              }
                              break;
                      }
                  });
              }
          });

          // 如果没有找到其他约束，使用默认值，否则使用找到的最大尺寸的1.5倍作为表面大小
          return maxSize > 0 ? maxSize * 1.5 : 50;
      }

      // 获取表面约束的大小
      function getSurfaceConstraintSize(constraintId) {
          if (surfaceConstraintSizes.has(constraintId)) {
              return surfaceConstraintSizes.get(constraintId);
          }

          // 首次访问时，设置基于场景的合理默认值
          const defaultSize = calculateSceneSize();
          surfaceConstraintSizes.set(constraintId, defaultSize);
          return defaultSize;
      }

      // 设置表面约束的大小
      function setSurfaceConstraintSize(constraintId, size) {
          surfaceConstraintSizes.set(constraintId, size);

          // 重新创建该约束的几何体
          const constraintObject = constraintGroups.get(constraintId);
          if (constraintObject) {
              // 获取约束数据
              const parts = constraintId.split('_constraint_');
              const structureId = parts[0];
              const constraintIndex = parseInt(parts[1]);

              const structure = currentData.input.structures.find(s => s.id === structureId);
              if (structure && structure.constraints && structure.constraints[constraintIndex]) {
                  const constraint = structure.constraints[constraintIndex];
                  
                  // 判断是否为表面约束（有箭头的Group）还是普通约束（单个Mesh）
                  if (constraint.geometry.type === 'plane' || constraint.geometry.type === 'xygauss') {
                      // 表面约束：重新创建整个组（包括箭头）
                      const parent = constraintObject.parent;
                      if (parent) {
                          // 移除旧的约束组
                          parent.remove(constraintObject);
                          
                          // 清理旧几何体
                          constraintObject.traverse(child => {
                              if (child.geometry) {
                                  child.geometry.dispose();
                              }
                              if (child.material) {
                                  if (child.material.map) {
                                      child.material.map.dispose();
                                  }
                                  child.material.dispose();
                              }
                          });
                          
                          // 创建新的约束可视化（包括新尺寸的几何体和箭头）
                          const newConstraintVisualization = createConstraintVisualization(constraint, constraintId);
                          if (newConstraintVisualization) {
                              parent.add(newConstraintVisualization);
                              constraintGroups.set(constraintId, newConstraintVisualization);
                          }
                      }
                  } else {
                      // 非表面约束：只更新几何体
                      const newGeometry = getConstraintGeometry(constraint.geometry, constraintId);
                      if (newGeometry && constraintObject.geometry) {
                          constraintObject.geometry.dispose(); // 清理旧几何体
                          constraintObject.geometry = newGeometry;
                      }
                  }
              }
          }
      }

      // 获取约束几何体
      function getConstraintGeometry(geometry, constraintId = null) {
          console.log('Getting constraint geometry:', geometry);
          switch (geometry.type) {
              case 'sphere':
                  if (geometry.parameters.length >= 4) {
                      const [x, y, z, radius] = geometry.parameters;
                      console.log(`Creating sphere at (${x}, ${y}, ${z}) with radius ${radius}`);
                      const sphereGeometry = new THREE.SphereGeometry(radius, currentSettings.geometrySegments, currentSettings.geometrySegments);
                      sphereGeometry.translate(x, y, z);
                      return sphereGeometry;
                  }
                  break;
              case 'box':
                  if (geometry.parameters.length >= 6) {
                      const [x1, y1, z1, x2, y2, z2] = geometry.parameters;
                      const width = Math.abs(x2 - x1);
                      const height = Math.abs(y2 - y1);
                      const depth = Math.abs(z2 - z1);
                      console.log(`Creating box from (${x1}, ${y1}, ${z1}) to (${x2}, ${y2}, ${z2})`);
                      const boxSegments = Math.max(1, Math.floor(currentSettings.geometrySegments / 8));
                      const boxGeometry = new THREE.BoxGeometry(width, height, depth, boxSegments, boxSegments, boxSegments);
                      boxGeometry.translate((x1 + x2) / 2, (y1 + y2) / 2, (z1 + z2) / 2);
                      return boxGeometry;
                  }
                  break;
              case 'cube':
                  // outside cube xmin ymin zmin d
                  if (geometry.parameters.length >= 4) {
                      const [xmin, ymin, zmin, d] = geometry.parameters;
                      console.log(`Creating cube at (${xmin}, ${ymin}, ${zmin}) with size ${d}`);
                      const cubeSegments = Math.max(1, Math.floor(currentSettings.geometrySegments / 8));
                      const cubeGeometry = new THREE.BoxGeometry(d, d, d, cubeSegments, cubeSegments, cubeSegments);
                      cubeGeometry.translate(xmin + d/2, ymin + d/2, zmin + d/2);
                      return cubeGeometry;
                  }
                  break;
              case 'cylinder':
                  if (geometry.parameters.length >= 8) {
                      const [a1, b1, c1, a2, b2, c2, d, l] = geometry.parameters;

                      // a1,b1,c1 是起点，a2,b2,c2 是方向向量，d 是半径，l 是长度
                      console.log(`Creating cylinder from (${a1}, ${b1}, ${c1}) direction (${a2}, ${b2}, ${c2}) radius ${d} length ${l}`);

                      // 标准化方向向量
                      const dirLength = Math.sqrt(a2*a2 + b2*b2 + c2*c2);
                      if (dirLength === 0) {
                          console.warn('Cylinder direction vector is zero');
                          break;
                      }
                      const dirX = a2 / dirLength;
                      const dirY = b2 / dirLength;
                      const dirZ = c2 / dirLength;

                      // 创建圆柱体几何
                      const cylinderGeometry = new THREE.CylinderGeometry(d, d, l, currentSettings.geometrySegments);

                      // Three.js 默认圆柱体沿 Y 轴，需要旋转到正确方向
                      // 计算从 Y 轴到目标方向的旋转
                      const yAxis = new THREE.Vector3(0, 1, 0);
                      const targetDir = new THREE.Vector3(dirX, dirY, dirZ);
                      const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, targetDir);
                      cylinderGeometry.applyQuaternion(quaternion);

                      // 移动到正确位置（圆柱体中心）
                      const centerX = a1 + (dirX * l / 2);
                      const centerY = b1 + (dirY * l / 2);
                      const centerZ = c1 + (dirZ * l / 2);
                      cylinderGeometry.translate(centerX, centerY, centerZ);

                      return cylinderGeometry;
                  }
                  break;
              case 'plane':
                  // above/below plane a b c d (ax + by + cz - d = 0)
                  if (geometry.parameters.length >= 4) {
                      const [a, b, c, d] = geometry.parameters;
                      console.log(`Creating plane with equation ${a}x + ${b}y + ${c}z - ${d} = 0`);

                      // 使用可调节的平面大小
                      const planeSize = constraintId ? getSurfaceConstraintSize(constraintId) : 50;
                      const planeSegments = Math.max(4, Math.floor(currentSettings.geometrySegments / 2));
                      const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize, planeSegments, planeSegments);

                      // 计算平面的法向量
                      const normal = new THREE.Vector3(a, b, c).normalize();

                      // 计算平面上的一个点
                      let point = new THREE.Vector3();
                      if (Math.abs(c) > 0.1) {
                          point.set(0, 0, d / c);
                      } else if (Math.abs(b) > 0.1) {
                          point.set(0, d / b, 0);
                      } else if (Math.abs(a) > 0.1) {
                          point.set(d / a, 0, 0);
                      }

                      // 将平面移动到正确位置并定向
                      planeGeometry.translate(point.x, point.y, point.z);
                      planeGeometry.lookAt(normal);

                      return planeGeometry;
                  }
                  break;
              case 'ellipsoid':
                  // 椭球体 (目前用球体近似，可以后续改进为真正的椭球体)
                  if (geometry.parameters.length >= 7) {
                      const [x, y, z, a, b, c, d] = geometry.parameters;
                      console.log(`Creating ellipsoid at (${x}, ${y}, ${z}) with semi-axes (${a/d}, ${b/d}, ${c/d})`);

                      // 创建单位球体然后缩放
                      const ellipsoidGeometry = new THREE.SphereGeometry(1, currentSettings.geometrySegments, currentSettings.geometrySegments);
                      ellipsoidGeometry.scale(a/d, b/d, c/d);
                      ellipsoidGeometry.translate(x, y, z);
                      return ellipsoidGeometry;
                  }
                  break;
              case 'xygauss':
                  // over/below xygauss a1 b1 a2 b2 c h
                  // 高斯表面: h * exp(-((x-a1)²/(2a2²) + (y-b1)²/(2b2²))) - (z-c) = 0
                  if (geometry.parameters.length >= 6) {
                      const [a1, b1, a2, b2, c, h] = geometry.parameters;
                      console.log(`Creating xygauss surface at (${a1}, ${b1}) with parameters a2=${a2}, b2=${b2}, c=${c}, h=${h}`);

                      // 使用可调节的表面范围大小
                      const surfaceSize = constraintId ? getSurfaceConstraintSize(constraintId) : Math.max(a2, b2) * 3;
                      const resolution = Math.max(8, currentSettings.geometrySegments);
                      const range = surfaceSize / 2;
                      const positions = [];
                      const indices = [];

                      for (let i = 0; i <= resolution; i++) {
                          for (let j = 0; j <= resolution; j++) {
                              const x = a1 + (i / resolution - 0.5) * range * 2;
                              const y = b1 + (j / resolution - 0.5) * range * 2;
                              const z = c + h * Math.exp(-((x - a1) ** 2) / (2 * a2 ** 2) - ((y - b1) ** 2) / (2 * b2 ** 2));

                              positions.push(x, y, z);
                          }
                      }

                      // 创建索引
                      for (let i = 0; i < resolution; i++) {
                          for (let j = 0; j < resolution; j++) {
                              const a = i * (resolution + 1) + j;
                              const b = a + resolution + 1;

                              indices.push(a, b, a + 1);
                              indices.push(b, b + 1, a + 1);
                          }
                      }

                      const gaussGeometry = new THREE.BufferGeometry();
                      gaussGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                      gaussGeometry.setIndex(indices);
                      gaussGeometry.computeVertexNormals();

                      return gaussGeometry;
                  }
                  break;
          }
          console.log('Could not create geometry for:', geometry);
          return null;
      }

      // 更新控制面板
      function updateControlPanel() {
          const structureList = document.getElementById('structure-list');
          const constraintList = document.getElementById('constraint-list');

          structureList.innerHTML = '';
          constraintList.innerHTML = '';

          if (!currentData || !currentData.input) return;

          // 结构列表（包含约束的层次结构）
          currentData.input.structures.forEach(structure => {
              // 创建结构容器
              const structureContainer = document.createElement('div');
              structureContainer.className = 'structure-container';
              structureContainer.style.marginBottom = '10px';
              structureContainer.style.border = '1px solid #444';
              structureContainer.style.borderRadius = '4px';
              structureContainer.style.padding = '8px';

              // 创建结构主项
              const structureItem = document.createElement('div');
              structureItem.className = 'structure-item';
              structureItem.style.fontWeight = 'bold';
              structureItem.style.marginBottom = '5px';

              const structureCheckbox = document.createElement('input');
              structureCheckbox.type = 'checkbox';
              structureCheckbox.className = 'structure-checkbox';
              structureCheckbox.checked = true;
              structureCheckbox.addEventListener('change', () => {
                  toggleStructureVisibility(structure.id, structureCheckbox.checked);
                  // 同时切换所有子约束的可见性
                  const constraintCheckboxes = structureContainer.querySelectorAll('.constraint-checkbox');
                  constraintCheckboxes.forEach(cb => {
                      cb.checked = structureCheckbox.checked;
                      const constraintId = cb.getAttribute('data-constraint-id');
                      if (constraintId) {
                          toggleConstraintVisibility(constraintId, structureCheckbox.checked);
                      }
                  });
              });

              const structureInfo = document.createElement('div');
              structureInfo.className = 'structure-info';
              structureInfo.style.display = 'flex';
              structureInfo.style.alignItems = 'center';
              structureInfo.style.flex = '1';

              const structureLabel = document.createElement('span');

              // 构建结构标签文本
              let labelText = '📦 ' + structure.filename + '<span class="structure-count">(' + structure.number + ')</span>';

              // 如果是单分子且有多球拟合数据，添加球体信息
              if (structure.number === 1 && structure.visualInfo &&
                  structure.visualInfo.geometry &&
                  structure.visualInfo.geometry.type === 'multi_sphere' &&
                  structure.visualInfo.geometry.spheres) {

                  const sphereCount = structure.visualInfo.geometry.spheres.length;
                  labelText += '<br><span style="font-size: 10px; color: #88c999;">🔮 ' + sphereCount + ' spheres fitted</span>';
              }

              structureLabel.innerHTML = labelText;
              structureLabel.style.flex = '1';

              // 添加颜色选择器
              const colorPicker = document.createElement('input');
              colorPicker.type = 'color';
              colorPicker.className = 'structure-color-picker';
              colorPicker.style.width = '20px';
              colorPicker.style.height = '20px';
              colorPicker.style.border = 'none';
              colorPicker.style.borderRadius = '3px';
              colorPicker.style.cursor = 'pointer';
              colorPicker.style.marginLeft = '8px';

              // 设置当前颜色
              const currentColor = getStructureColor(structure.id);
              colorPicker.value = '#' + currentColor.toString(16).padStart(6, '0');

              colorPicker.addEventListener('change', (event) => {
                  const newColor = parseInt(event.target.value.slice(1), 16);
                  setStructureColor(structure.id, newColor);
              });

              structureInfo.appendChild(structureLabel);
              structureInfo.appendChild(colorPicker);

              structureItem.appendChild(structureCheckbox);
              structureItem.appendChild(structureInfo);
              structureContainer.appendChild(structureItem);

              // 添加多球拟合信息（如果有）
              if (structure.number === 1 && structure.visualInfo &&
                  structure.visualInfo.geometry &&
                  structure.visualInfo.geometry.type === 'multi_sphere' &&
                  structure.visualInfo.geometry.spheres) {

                  const multisphereInfo = document.createElement('div');
                  multisphereInfo.style.marginLeft = '20px';
                  multisphereInfo.style.borderLeft = '2px solid #88c999';
                  multisphereInfo.style.paddingLeft = '8px';
                  multisphereInfo.style.marginTop = '5px';
                  multisphereInfo.style.marginBottom = '5px';

                  const spheres = structure.visualInfo.geometry.spheres;

                  // 多球拟合总览
                  const multisphereHeader = document.createElement('div');
                  multisphereHeader.style.fontSize = '11px';
                  multisphereHeader.style.color = '#88c999';
                  multisphereHeader.style.fontWeight = 'bold';
                  multisphereHeader.style.marginBottom = '3px';
                  multisphereHeader.textContent = '🔮 Multi-sphere Fitting (' + spheres.length + ' spheres)';
                  multisphereInfo.appendChild(multisphereHeader);

                  // 计算总体积
                  const totalVolume = spheres.reduce((sum, sphere) =>
                      sum + (4/3) * Math.PI * Math.pow(sphere.radius, 3), 0);

                  // 平均半径
                  const avgRadius = spheres.reduce((sum, sphere) => sum + sphere.radius, 0) / spheres.length;

                  // 显示统计信息
                  const statsDiv = document.createElement('div');
                  statsDiv.style.fontSize = '10px';
                  statsDiv.style.color = '#aaa';
                  statsDiv.style.marginBottom = '3px';
                  statsDiv.textContent = 'Volume: ' + totalVolume.toFixed(1) + ' Å³, Avg radius: ' + avgRadius.toFixed(1) + ' Å';
                  multisphereInfo.appendChild(statsDiv);

                  // 显示每个球体（最多显示前5个）
                  const maxDisplaySpheres = Math.min(5, spheres.length);
                  for (let i = 0; i < maxDisplaySpheres; i++) {
                      const sphere = spheres[i];
                      const sphereItem = document.createElement('div');
                      sphereItem.style.fontSize = '9px';
                      sphereItem.style.color = '#999';
                      sphereItem.style.marginLeft = '10px';
                      sphereItem.style.marginBottom = '1px';

                      const centerStr = sphere.center.map(c => c.toFixed(1)).join(', ');
                      sphereItem.textContent = '• Sphere ' + (i + 1) + ': (' + centerStr + ') r=' + sphere.radius.toFixed(1);
                      multisphereInfo.appendChild(sphereItem);
                  }

                  // 如果有更多球体，显示省略信息
                  if (spheres.length > maxDisplaySpheres) {
                      const moreInfo = document.createElement('div');
                      moreInfo.style.fontSize = '9px';
                      moreInfo.style.color = '#777';
                      moreInfo.style.marginLeft = '10px';
                      moreInfo.style.fontStyle = 'italic';
                      moreInfo.textContent = '... and ' + (spheres.length - maxDisplaySpheres) + ' more spheres';
                      multisphereInfo.appendChild(moreInfo);
                  }

                  structureContainer.appendChild(multisphereInfo);
              }

              // 添加约束子项
              if (structure.constraints && structure.constraints.length > 0) {
                  const constraintsSublist = document.createElement('div');
                  constraintsSublist.style.marginLeft = '20px';
                  constraintsSublist.style.borderLeft = '2px solid #666';
                  constraintsSublist.style.paddingLeft = '8px';

                  structure.constraints.forEach((constraint, index) => {
                      const constraintItem = document.createElement('div');
                      constraintItem.className = 'structure-item constraint-item';
                      constraintItem.style.fontSize = '11px';
                      constraintItem.style.color = '#bbb';
                      constraintItem.style.marginBottom = '3px';

                      const constraintCheckbox = document.createElement('input');
                      constraintCheckbox.type = 'checkbox';
                      constraintCheckbox.className = 'structure-checkbox constraint-checkbox';
                      constraintCheckbox.checked = true;
                      const constraintId = structure.id + '_constraint_' + index;
                      constraintCheckbox.setAttribute('data-constraint-id', constraintId);
                      constraintCheckbox.addEventListener('change', () => {
                          toggleConstraintVisibility(constraintId, constraintCheckbox.checked);
                          // 检查是否所有约束都被取消选中，如果是，则取消选中结构
                          const allConstraintCheckboxes = constraintsSublist.querySelectorAll('.constraint-checkbox');
                          const anyChecked = Array.from(allConstraintCheckboxes).some(cb => cb.checked);
                          structureCheckbox.checked = anyChecked;
                          toggleStructureVisibility(structure.id, anyChecked);
                      });

                      const constraintInfo = document.createElement('div');
                      constraintInfo.className = 'structure-info';

                      // 更详细的约束信息
                      let constraintText = `🔧 ${constraint.type} ${constraint.geometry.type}`;
                      if (constraint.geometry.parameters) {
                          switch (constraint.geometry.type) {
                              case 'sphere':
                                  if (constraint.geometry.parameters.length >= 4) {
                                      const [x, y, z, r] = constraint.geometry.parameters;
                                      constraintText += ` (r=${r.toFixed(1)})`;
                                  }
                                  break;
                              case 'box':
                                  if (constraint.geometry.parameters.length >= 6) {
                                      const [x1, y1, z1, x2, y2, z2] = constraint.geometry.parameters;
                                      const w = Math.abs(x2 - x1);
                                      const h = Math.abs(y2 - y1);
                                      const d = Math.abs(z2 - z1);
                                      constraintText += ` (${w.toFixed(1)}×${h.toFixed(1)}×${d.toFixed(1)})`;
                                  }
                                  break;
                              case 'cube':
                                  if (constraint.geometry.parameters.length >= 4) {
                                      const d = constraint.geometry.parameters[3];
                                      constraintText += ` (size=${d.toFixed(1)})`;
                                  }
                                  break;
                              case 'cylinder':
                                  if (constraint.geometry.parameters.length >= 7) {
                                      const r = constraint.geometry.parameters[6];
                                      constraintText += ` (r=${r.toFixed(1)})`;
                                  }
                                  break;
                              case 'plane':
                                  if (constraint.geometry.parameters.length >= 4) {
                                      const [a, b, c, d] = constraint.geometry.parameters;
                                      constraintText += ` (${a.toFixed(1)}x+${b.toFixed(1)}y+${c.toFixed(1)}z=${d.toFixed(1)})`;
                                  }
                                  break;
                              case 'ellipsoid':
                                  if (constraint.geometry.parameters.length >= 6) {
                                      const [x, y, z, a, b, c] = constraint.geometry.parameters;
                                      constraintText += ` (a=${a.toFixed(1)}, b=${b.toFixed(1)}, c=${c.toFixed(1)})`;
                                  }
                                  break;
                              case 'xygauss':
                                  if (constraint.geometry.parameters.length >= 6) {
                                      const [a1, b1, a2, b2, c, h] = constraint.geometry.parameters;
                                      constraintText += ` (σx=${a2.toFixed(1)}, σy=${b2.toFixed(1)}, h=${h.toFixed(1)})`;
                                  }
                                  break;
                          }
                      }
                      constraintInfo.textContent = constraintText;

                      constraintItem.appendChild(constraintCheckbox);
                      constraintItem.appendChild(constraintInfo);

                      constraintsSublist.appendChild(constraintItem);

                      // 为表面约束添加大小滑块（放在约束项下方）
                      if (constraint.geometry.type === 'plane' || constraint.geometry.type === 'xygauss') {
                          const sliderContainer = document.createElement('div');
                          sliderContainer.className = 'surface-slider-container';
                          sliderContainer.style.marginLeft = '25px'; // 与约束项对齐
                          sliderContainer.style.marginTop = '3px';
                          sliderContainer.style.marginBottom = '5px';

                          const sliderLabel = document.createElement('span');
                          sliderLabel.textContent = 'Size:';
                          sliderLabel.style.fontSize = '10px';
                          sliderLabel.style.color = '#999';
                          sliderLabel.style.minWidth = '30px';
                          sliderLabel.style.display = 'inline-block';

                          const slider = document.createElement('input');
                          slider.type = 'range';
                          slider.className = 'surface-slider';
                          slider.min = '10';
                          slider.max = '200';
                          slider.step = '2';
                          slider.style.margin = '0 5px';
                          slider.style.width = '105px'; // 限制滑块宽度

                          // 获取当前大小
                          const currentSize = getSurfaceConstraintSize(constraintId);
                          slider.value = currentSize.toString();

                          const valueDisplay = document.createElement('span');
                          valueDisplay.style.fontSize = '10px';
                          valueDisplay.style.color = '#999';
                          valueDisplay.style.minWidth = '25px';
                          valueDisplay.style.display = 'inline-block';
                          valueDisplay.textContent = currentSize.toFixed(0);

                          // 滑块变化事件
                          slider.addEventListener('input', () => {
                              const newSize = parseFloat(slider.value);
                              valueDisplay.textContent = newSize.toFixed(0);
                              setSurfaceConstraintSize(constraintId, newSize);
                          });

                          sliderContainer.appendChild(sliderLabel);
                          sliderContainer.appendChild(slider);
                          sliderContainer.appendChild(valueDisplay);
                          constraintsSublist.appendChild(sliderContainer);
                      }
                  });

                  structureContainer.appendChild(constraintsSublist);
              }

              structureList.appendChild(structureContainer);
          });

          // 在约束区域显示全局统计信息
          const statsDiv = document.createElement('div');
          statsDiv.style.fontSize = '11px';
          statsDiv.style.color = '#888';
          statsDiv.style.padding = '5px';
          statsDiv.style.borderTop = '1px solid #444';

          const totalStructures = currentData.input.structures.length;
          const totalConstraints = currentData.input.structures.reduce((sum, s) => sum + (s.constraints?.length || 0), 0);
          statsDiv.textContent = `Total: ${totalStructures} structures, ${totalConstraints} constraints`;

          constraintList.appendChild(statsDiv);
      }

      // 切换结构可见性
      function toggleStructureVisibility(structureId, visible) {
          const group = structureGroups.get(structureId);
          if (group) {
              group.visible = visible;
          }
      }

      // 切换约束可见性
      function toggleConstraintVisibility(constraintId, visible) {
          const constraintMesh = constraintGroups.get(constraintId);
          if (constraintMesh) {
              constraintMesh.visible = visible;
          }
      }

      // 重置相机
      function resetCamera() {
          camera.position.set(50, 50, 50);
          camera.lookAt(0, 0, 0);
          fitCameraToScene();
      }

      // 切换线框模式
      function toggleWireframe() {
          wireframeMode = !wireframeMode;
          structureGroups.forEach(group => {
              group.traverse(child => {
                  if (child.material) {
                      child.material.wireframe = wireframeMode;
                  }
              });
          });
          constraintGroups.forEach(group => {
              if (group.material) {
                  group.material.wireframe = wireframeMode;
              }
          });
      }

      // 随机化颜色
      function randomizeColors() {
          if (!currentData || !currentData.input || !currentData.input.structures) return;

          currentData.input.structures.forEach(structure => {
              // 生成随机颜色
              const randomColor = Math.floor(Math.random() * 16777215); // 0xFFFFFF
              setStructureColor(structure.id, randomColor);
          });

          // 更新控制面板中的颜色选择器
          updateControlPanel();
      }

      // 重置颜色
      function resetColors() {
          if (!window.structureColorMap) return;

          // 清除颜色映射
          window.structureColorMap.clear();
          window.structureColorIndex = 0;

          if (!currentData || !currentData.input || !currentData.input.structures) return;

          // 重新分配默认颜色
          currentData.input.structures.forEach(structure => {
              const defaultColor = getStructureColor(structure.id);
              updateStructureColors(structure.id, defaultColor);
          });

          // 更新控制面板中的颜色选择器
          updateControlPanel();
      }

      // 调整相机适应场景
      function fitCameraToScene() {
          const box = new THREE.Box3();
          scene.traverse(object => {
              if (object.geometry) {
                  box.expandByObject(object);
              }
          });

          if (!box.isEmpty()) {
              const center = box.getCenter(new THREE.Vector3());
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const distance = maxDim * 2;

              camera.position.set(center.x + distance, center.y + distance, center.z + distance);
              camera.lookAt(center);
          }
      }

      // 获取结构颜色
      function getStructureColor(structureId) {
          const colors = [
              0xff6b6b,  // 红色
              0x4ecdc4,  // 青色
              0x45b7d1,  // 蓝色
              0x96ceb4,  // 绿色
              0xffeaa7,  // 黄色
              0xdda0dd,  // 紫色
              0x74b9ff,  // 亮蓝色
              0xfd79a8,  // 粉色
              0xa29bfe,  // 淡紫色
              0x6c5ce7   // 深紫色
          ];

          // 为每个结构分配一个固定的颜色索引
          if (!window.structureColorMap) {
              window.structureColorMap = new Map();
              window.structureColorIndex = 0;
          }

          if (!window.structureColorMap.has(structureId)) {
              window.structureColorMap.set(structureId, colors[window.structureColorIndex % colors.length]);
              window.structureColorIndex++;
          }

          return window.structureColorMap.get(structureId);
      }

      // 设置结构颜色
      function setStructureColor(structureId, color) {
          if (!window.structureColorMap) {
              window.structureColorMap = new Map();
          }
          window.structureColorMap.set(structureId, color);

          // 更新现有的结构颜色
          updateStructureColors(structureId, color);
      }

      // 更新结构颜色
      function updateStructureColors(structureId, color) {
          const group = structureGroups.get(structureId);
          if (group) {
              group.traverse(child => {
                  if (child.material && (child.name === structureId || child.name.includes(structureId))) {
                      child.material.color.setHex(color);
                  }
              });
          }

          // 更新约束颜色
          constraintGroups.forEach((constraintGroup, constraintId) => {
              if (constraintId.startsWith(structureId)) {
                  if (constraintGroup.material) {
                      // 约束使用稍微透明的结构颜色
                      const constraintColor = new THREE.Color(color);
                      constraintColor.multiplyScalar(0.7); // 稍微暗一些
                      constraintGroup.material.color = constraintColor;
                  }
              }
          });
      }

      // ========== 表面约束箭头功能 ==========

      // 存储当前处理的约束信息
      let currentConstraintInfo = null;

      // 为表面约束创建方向箭头
      function createSurfaceDirectionArrows(constraint, color, constraintId) {
          currentConstraintInfo = constraint; // 设置当前约束信息
          const arrows = [];
          const arrowColor = new THREE.Color(color);
          arrowColor.multiplyScalar(1.2); // 稍微亮一些以便区分
          
          if (constraint.geometry.type === 'plane') {
              arrows.push(...createPlaneDirectionArrows(constraint, arrowColor, constraintId));
          } else if (constraint.geometry.type === 'xygauss') {
              arrows.push(...createXYGaussDirectionArrows(constraint, arrowColor, constraintId));
          }
          
          currentConstraintInfo = null; // 清除约束信息
          return arrows;
      }

      // 为平面约束创建方向箭头
      function createPlaneDirectionArrows(constraint, color, constraintId) {
          const arrows = [];
          const [a, b, c, d] = constraint.geometry.parameters;
          
          // 计算平面法向量
          const normal = new THREE.Vector3(a, b, c).normalize();
          
          // 计算平面上的参考点
          let planePoint = new THREE.Vector3();
          if (Math.abs(c) > 0.1) {
              planePoint.set(0, 0, d / c);
          } else if (Math.abs(b) > 0.1) {
              planePoint.set(0, d / b, 0);
          } else if (Math.abs(a) > 0.1) {
              planePoint.set(d / a, 0, 0);
          }
          
          // 根据约束类型确定箭头方向
          let arrowDirection = normal.clone();
          if (constraint.type === 'below') {
              arrowDirection.negate(); // below 时方向相反
          }
          
          // 获取当前表面大小并调整箭头间距
          const surfaceSize = constraintId ? getSurfaceConstraintSize(constraintId) : 50;
          const arrowSpacing = Math.min(surfaceSize * 0.2, 15); // 根据表面大小调整箭头间距
          
          // 创建多个箭头显示在平面上不同位置
          const arrowPositions = [
              planePoint.clone(),
              planePoint.clone().add(new THREE.Vector3(arrowSpacing, 0, 0)),
              planePoint.clone().add(new THREE.Vector3(-arrowSpacing, 0, 0)),
              planePoint.clone().add(new THREE.Vector3(0, arrowSpacing, 0)),
              planePoint.clone().add(new THREE.Vector3(0, -arrowSpacing, 0)),
              planePoint.clone().add(new THREE.Vector3(arrowSpacing * 0.7, arrowSpacing * 0.7, 0)),
              planePoint.clone().add(new THREE.Vector3(-arrowSpacing * 0.7, -arrowSpacing * 0.7, 0))
          ];
          
          arrowPositions.forEach((position, index) => {
              const arrow = createArrow(position, arrowDirection, 8, color, constraint.type);
              arrow.name = `plane_arrow_${index}`;
              arrows.push(arrow);
          });
          
          console.log(`Created ${arrows.length} plane arrows for ${constraint.type} constraint`);
          return arrows;
      }

      // 为 XY 高斯表面约束创建方向箭头
      function createXYGaussDirectionArrows(constraint, color, constraintId) {
          const arrows = [];
          const [a1, b1, a2, b2, c, h] = constraint.geometry.parameters;
          
          // 高斯表面的中心点
          const centerPoint = new THREE.Vector3(a1, b1, c);
          
          // 根据约束类型确定箭头方向（高斯表面始终在 XY 平面，方向为 Z 轴）
          let arrowDirection = new THREE.Vector3(0, 0, 1);
          if (constraint.type === 'below') {
              arrowDirection.negate(); // below 时指向 -Z 方向
          }
          
          // 获取当前表面大小并调整箭头分布
          const surfaceSize = constraintId ? getSurfaceConstraintSize(constraintId) : Math.max(a2, b2) * 3;
          const scaleFactor = Math.min(surfaceSize / (Math.max(a2, b2) * 3), 2.0); // 限制最大缩放倍数
          
          // 在高斯表面的几个特征点创建箭头
          const arrowPositions = [
              centerPoint.clone(), // 中心
              centerPoint.clone().add(new THREE.Vector3(a2 * 0.8 * scaleFactor, 0, 0)), // X 方向偏移
              centerPoint.clone().add(new THREE.Vector3(-a2 * 0.8 * scaleFactor, 0, 0)),
              centerPoint.clone().add(new THREE.Vector3(0, b2 * 0.8 * scaleFactor, 0)), // Y 方向偏移
              centerPoint.clone().add(new THREE.Vector3(0, -b2 * 0.8 * scaleFactor, 0)),
              centerPoint.clone().add(new THREE.Vector3(a2 * 0.6 * scaleFactor, b2 * 0.6 * scaleFactor, 0)), // 对角位置
              centerPoint.clone().add(new THREE.Vector3(-a2 * 0.6 * scaleFactor, -b2 * 0.6 * scaleFactor, 0))
          ];
          
          arrowPositions.forEach((position, index) => {
              // 计算该位置的高斯表面高度
              const gaussHeight = h * Math.exp(-((position.x - a1) ** 2) / (2 * a2 ** 2) - ((position.y - b1) ** 2) / (2 * b2 ** 2));
              position.z = c + gaussHeight;
              
              const arrow = createArrow(position, arrowDirection, 6, color, constraint.type);
              arrow.name = `xygauss_arrow_${index}`;
              arrows.push(arrow);
          });
          
          console.log(`Created ${arrows.length} xygauss arrows for ${constraint.type} constraint`);
          return arrows;
      }

      // 创建箭头几何体
      function createArrow(position, direction, length, color, constraintType) {
          const arrowGroup = new THREE.Group();
          
          // 标准化方向向量
          const normalizedDirection = direction.clone().normalize();
          
          // 创建箭头主体（圆柱体）
          const shaftLength = length * 0.7;
          const shaftRadius = length * 0.025;
          const shaftGeometry = new THREE.CylinderGeometry(shaftRadius, shaftRadius, shaftLength, 8);
          const shaftMaterial = new THREE.MeshLambertMaterial({ 
              color: color,
              transparent: true,
              opacity: 0.8
          });
          const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
          
          // 创建箭头头部（圆锥体）
          const headLength = length * 0.3;
          const headRadius = length * 0.08;
          const headGeometry = new THREE.ConeGeometry(headRadius, headLength, 8);
          const headMaterial = new THREE.MeshLambertMaterial({ 
              color: color,
              transparent: true,
              opacity: 0.9
          });
          const head = new THREE.Mesh(headGeometry, headMaterial);
          
          // 定位箭头组件
          shaft.position.set(0, shaftLength / 2, 0);
          head.position.set(0, shaftLength + headLength / 2, 0);
          
          arrowGroup.add(shaft);
          arrowGroup.add(head);
          
          // 旋转箭头使其指向正确方向
          const yAxis = new THREE.Vector3(0, 1, 0);
          const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, normalizedDirection);
          arrowGroup.applyQuaternion(quaternion);
          
          // 设置箭头位置
          arrowGroup.position.copy(position);
          
          // 添加约束类型标签（小的文字提示）
          if (constraintType) {
              const textSprite = createTextSprite(constraintType.toUpperCase(), color);
              textSprite.position.set(0, length + 2, 0);
              arrowGroup.add(textSprite);
          }
          
          return arrowGroup;
      }

      // 创建文字精灵（用于显示约束类型）
      function createTextSprite(text, color) {
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = 128;
          canvas.height = 64;
          
          // 设置画布背景为半透明黑色
          context.fillStyle = 'rgba(0, 0, 0, 0.7)';
          context.fillRect(0, 0, canvas.width, canvas.height);
          
          // 绘制文字
          context.font = 'bold 20px Arial';
          context.fillStyle = `#${color.getHexString()}`;
          context.strokeStyle = '#000000';
          context.lineWidth = 2;
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          
          // 先描边再填充，产生边框效果
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillText(text, canvas.width / 2, canvas.height / 2);
          
          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({ 
              map: texture,
              transparent: true,
              opacity: 0.9
          });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(3, 1.5, 1); // 稍微调整大小使其更清晰
          
          return sprite;
      }

      // 消息处理
      window.addEventListener('message', event => {
          console.log('=== WEBVIEW MESSAGE RECEIVED ===');
          console.log('Message data:', event.data);
          console.log('Three.js ready status:', isThreeJSReady);

          const message = event.data;

          // 添加视觉确认
          if (message.type === 'update') {
              console.log('📦 UPDATE message received! Creating alert...');
              // alert('收到 UPDATE 消息！正在处理...');
          }

          if (!isThreeJSReady && message.type !== 'ready') {
              console.log('⚠️ Three.js not ready, ignoring message:', message);
              // alert('Three.js 还未准备好，忽略消息: ' + message.type);
              return;
          }

          switch (message.type) {
              case 'update':
                  console.log('🎯 Processing update message');
                  try {
                      updateData(message);
                      console.log('✅ Update processing completed');
                  } catch (error) {
                      console.error('❌ Error in updateData:', error);
                      // alert('更新数据时出错: ' + error.message);
                  }
                  break;
              case 'toggleStructure':
                  console.log('🔄 Processing toggleStructure message');
                  toggleStructureVisibility(message.structureId, message.visible);
                  break;
              case 'resetCamera':
                  console.log('📷 Processing resetCamera message');
                  resetCamera();
                  break;
              default:
                  console.log('❓ Unknown message type:', message.type);
          }

          console.log('=== MESSAGE PROCESSING COMPLETE ===');
      });

      // 切换多球显示
      let multisphereVisible = true;
      function toggleMultisphere() {
          multisphereVisible = !multisphereVisible;

          structureGroups.forEach(group => {
              group.traverse(child => {
                  // 切换多球和相关元素的可见性
                  if (child.name && (
                      child.name.includes('_multisphere_') ||
                      child.name.includes('_centroid') ||
                      child.name.includes('bond_')
                  )) {
                      child.visible = multisphereVisible;
                  }
              });
          });

          console.log('Multisphere visibility toggled to:', multisphereVisible);
      }

      // 切换表面箭头显示
      let surfaceArrowsVisible = true;
      function toggleSurfaceArrows() {
          surfaceArrowsVisible = !surfaceArrowsVisible;

          // 遍历所有约束组，切换箭头的可见性
          constraintGroups.forEach(constraintGroup => {
              if (constraintGroup.children) {
                  constraintGroup.traverse(child => {
                      // 切换箭头和相关元素的可见性
                      if (child.name && (
                          child.name.includes('plane_arrow_') ||
                          child.name.includes('xygauss_arrow_')
                      )) {
                          child.visible = surfaceArrowsVisible;
                      }
                  });
              }
          });

          // 同时遍历结构组中的约束（因为约束可能作为结构的子对象存在）
          structureGroups.forEach(group => {
              group.traverse(child => {
                  if (child.name && (
                      child.name.includes('plane_arrow_') ||
                      child.name.includes('xygauss_arrow_')
                  )) {
                      child.visible = surfaceArrowsVisible;
                  }
              });
          });

          console.log('Surface arrows visibility toggled to:', surfaceArrowsVisible);
      }

      // ========== 设置功能 ==========

      /**
       * 从扩展端应用配置
       */
      function applySettingsFromExtension(settings) {
          console.log('📝 Applying settings from extension:', settings);
          
          // 更新当前设置
          currentSettings = { ...currentSettings, ...settings };
          
          // 更新UI显示
          updateSettingsUI();
          
          // 应用设置到场景
          applyAllSettings();
          
          console.log('✅ Settings applied from extension');
      }

      /**
       * 发送设置更新到扩展端
       */
      function sendSettingsToExtension(settings) {
          if (vscode) {
              try {
                  vscode.postMessage({
                      type: 'updateSettings',
                      settings: settings
                  });
                  console.log('📤 Settings sent to extension:', settings);
              } catch (error) {
                  console.error('❌ Failed to send settings to extension:', error);
              }
          }
      }

      // 初始化设置界面
      function initializeSettings() {
          console.log('🎛️ Initializing settings interface...');
          
          // 生成主题选项
          generateThemeOptions();
          
          // 生成背景色预设
          generateBackgroundPresets();
          
          // 更新UI显示值
          updateSettingsUI();
          
          console.log('✅ Settings interface initialized');
      }

      // 生成主题选项
      function generateThemeOptions() {
          const themeGrid = document.getElementById('theme-grid');
          themeGrid.innerHTML = '';
          
          Object.keys(colorThemes).forEach(themeKey => {
              const theme = colorThemes[themeKey];
              const themeDiv = document.createElement('div');
              themeDiv.className = 'theme-option';
              themeDiv.onclick = () => selectTheme(themeKey);
              
              if (themeKey === currentSettings.colorTheme) {
                  themeDiv.classList.add('active');
              }
              
              themeDiv.innerHTML = `
                  <div>${theme.name}</div>
                  <div class="theme-colors">
                      ${theme.colors.slice(0, 3).map(color => 
                          `<div class="theme-color" style="background-color: #${color.toString(16).padStart(6, '0')};"></div>`
                      ).join('')}
                  </div>
              `;
              
              themeGrid.appendChild(themeDiv);
          });
      }

      // 生成背景色预设
      function generateBackgroundPresets() {
          const presetsGrid = document.getElementById('background-presets');
          presetsGrid.innerHTML = '';
          
          backgroundPresets.forEach(preset => {
              const presetDiv = document.createElement('div');
              presetDiv.className = 'color-preset';
              presetDiv.style.backgroundColor = preset.color;
              presetDiv.title = preset.name;
              presetDiv.onclick = () => {
                  document.getElementById('background-color').value = preset.color;
                  updateBackgroundColor(preset.color);
              };
              
              if (preset.color === currentSettings.backgroundColor) {
                  presetDiv.classList.add('active');
              }
              
              presetsGrid.appendChild(presetDiv);
          });
      }

      // 切换设置面板
      function toggleSettings() {
          const panel = document.getElementById('settings-panel');
          panel.classList.toggle('visible');
      }

      // 选择主题
      function selectTheme(themeKey) {
          currentSettings.colorTheme = themeKey;
          
          // 发送到扩展端保存
          sendSettingsToExtension({ colorTheme: themeKey });
          
          // 更新主题选项的活动状态
          document.querySelectorAll('.theme-option').forEach(option => {
              option.classList.remove('active');
          });
          event.target.classList.add('active');
          
          // 应用新主题
          applyColorTheme();
          
          console.log('Applied color theme:', themeKey);
      }

      // 应用颜色主题
      function applyColorTheme() {
          if (!window.structureColorMap) {
              window.structureColorMap = new Map();
              window.structureColorIndex = 0;
          }
          
          // 清除现有颜色映射
          window.structureColorMap.clear();
          window.structureColorIndex = 0;
          
          // 为每个结构重新分配颜色
          if (currentData && currentData.input && currentData.input.structures) {
              currentData.input.structures.forEach(structure => {
                  const newColor = getStructureColor(structure.id);
                  updateStructureColors(structure.id, newColor);
              });
          }
          
          // 更新控制面板
          updateControlPanel();
      }

      // 更新几何体分段数
      function updateGeometrySegments(value) {
          const newValue = parseInt(value);
          currentSettings.geometrySegments = newValue;
          document.getElementById('segments-value').textContent = value;
          
          // 发送到扩展端保存
          sendSettingsToExtension({ geometrySegments: newValue });
          
          // 重新生成所有几何体以应用新的分段数
          console.log('Updating geometry segments to:', value);
          
          if (currentData && currentData.input && currentData.input.structures) {
              // 清除现有几何体
              structureGroups.forEach(group => {
                  scene.remove(group);
              });
              structureGroups.clear();
              constraintGroups.clear();
              
              // 重新创建几何体
              currentData.input.structures.forEach((structure) => {
                  createStructureVisualization(structure);
              });
              
              console.log('Regenerated all geometries with', value, 'segments');
          }
      }

      // 更新结构透明度
      function updateOpacity(value) {
          const newValue = parseFloat(value);
          currentSettings.structureOpacity = newValue;
          document.getElementById('opacity-value').textContent = newValue.toFixed(2);
          
          // 发送到扩展端保存
          sendSettingsToExtension({ structureOpacity: newValue });
          
          // 应用到所有结构材质
          structureGroups.forEach(group => {
              group.traverse(child => {
                  if (child.material && !child.name.includes('wireframe')) {
                      child.material.opacity = currentSettings.structureOpacity;
                      child.material.transparent = true;
                  }
              });
          });
          
          console.log('Updated structure opacity to:', value);
      }

      // 更新约束透明度
      function updateConstraintOpacity(value) {
          const newValue = parseFloat(value);
          currentSettings.constraintOpacity = newValue;
          document.getElementById('constraint-opacity-value').textContent = newValue.toFixed(2);
          
          // 发送到扩展端保存
          sendSettingsToExtension({ constraintOpacity: newValue });
          
          // 应用到所有约束材质（包括箭头）
          constraintGroups.forEach(constraintMesh => {
              constraintMesh.traverse(child => {
                  if (child.material) {
                      child.material.opacity = currentSettings.constraintOpacity;
                      child.material.transparent = true;
                  }
              });
          });
          
          // 同时更新结构组中的约束箭头
          structureGroups.forEach(group => {
              group.traverse(child => {
                  if (child.name && (
                      child.name.includes('plane_arrow_') ||
                      child.name.includes('xygauss_arrow_')
                  ) && child.material) {
                      child.material.opacity = currentSettings.constraintOpacity;
                      child.material.transparent = true;
                  }
              });
          });
          
          console.log('Updated constraint opacity to:', value);
      }

      // 更新背景颜色
      function updateBackgroundColor(value) {
          currentSettings.backgroundColor = value;
          
          // 发送到扩展端保存
          sendSettingsToExtension({ backgroundColor: value });
          
          if (scene) {
              scene.background = new THREE.Color(value);
          }
          
          // 更新背景预设的活动状态
          document.querySelectorAll('.color-preset').forEach(preset => {
              preset.classList.remove('active');
              if (preset.style.backgroundColor === value || 
                  preset.style.backgroundColor === new THREE.Color(value).getStyle()) {
                  preset.classList.add('active');
              }
          });
          
          console.log('Updated background color to:', value);
      }

      // 更新环境光强度
      function updateAmbientLight(value) {
          const newValue = parseFloat(value);
          currentSettings.ambientLightIntensity = newValue;
          document.getElementById('ambient-light-value').textContent = value;
          
          // 发送到扩展端保存
          sendSettingsToExtension({ ambientLightIntensity: newValue });
          
          if (ambientLight) {
              ambientLight.intensity = currentSettings.ambientLightIntensity;
          }
          
          console.log('Updated ambient light intensity to:', value);
      }

      // 更新方向光强度
      function updateDirectionalLight(value) {
          const newValue = parseFloat(value);
          currentSettings.directionalLightIntensity = newValue;
          document.getElementById('directional-light-value').textContent = value;
          
          // 发送到扩展端保存
          sendSettingsToExtension({ directionalLightIntensity: newValue });
          
          if (directionalLight) {
              directionalLight.intensity = currentSettings.directionalLightIntensity;
          }
          
          console.log('Updated directional light intensity to:', value);
      }

      // 重置所有设置
      function resetSettings() {
          const defaultSettings = {
              geometrySegments: 16,
              structureOpacity: 0.6,
              constraintOpacity: 0.3,
              backgroundColor: '#1e1e1e',
              ambientLightIntensity: 0.6,
              directionalLightIntensity: 0.8,
              colorTheme: 'default'
          };
          
          currentSettings = { ...defaultSettings };
          
          // 发送到扩展端保存
          sendSettingsToExtension(defaultSettings);
          
          // 更新UI
          updateSettingsUI();
          
          // 应用设置
          applyAllSettings();
          
          console.log('Reset all settings to defaults');
      }

      // 更新设置UI显示
      function updateSettingsUI() {
          document.getElementById('segments-slider').value = currentSettings.geometrySegments;
          document.getElementById('segments-value').textContent = currentSettings.geometrySegments;
          
          document.getElementById('opacity-slider').value = currentSettings.structureOpacity;
          document.getElementById('opacity-value').textContent = currentSettings.structureOpacity.toFixed(2);
          
          document.getElementById('constraint-opacity-slider').value = currentSettings.constraintOpacity;
          document.getElementById('constraint-opacity-value').textContent = currentSettings.constraintOpacity.toFixed(2);
          
          document.getElementById('background-color').value = currentSettings.backgroundColor;
          
          document.getElementById('ambient-light-slider').value = currentSettings.ambientLightIntensity;
          document.getElementById('ambient-light-value').textContent = currentSettings.ambientLightIntensity.toFixed(1);
          
          document.getElementById('directional-light-slider').value = currentSettings.directionalLightIntensity;
          document.getElementById('directional-light-value').textContent = currentSettings.directionalLightIntensity.toFixed(1);
          
          // 更新主题选择
          document.querySelectorAll('.theme-option').forEach(option => {
              option.classList.remove('active');
          });
          const activeThemeIndex = Object.keys(colorThemes).indexOf(currentSettings.colorTheme);
          if (activeThemeIndex >= 0) {
              document.querySelectorAll('.theme-option')[activeThemeIndex]?.classList.add('active');
          }
      }

      // 应用所有设置
      function applyAllSettings() {
          updateGeometrySegments(currentSettings.geometrySegments);
          updateOpacity(currentSettings.structureOpacity);
          updateConstraintOpacity(currentSettings.constraintOpacity);
          updateBackgroundColor(currentSettings.backgroundColor);
          updateAmbientLight(currentSettings.ambientLightIntensity);
          updateDirectionalLight(currentSettings.directionalLightIntensity);
          applyColorTheme();
      }

      // 保存设置（现在设置会自动同步到VS Code配置）
      function saveSettings() {
          // 显示提示 - 设置已经自动同步到 VS Code
          const originalText = event.target.textContent;
          event.target.textContent = '✅ 已同步';
          event.target.style.background = '#28a745';
          setTimeout(() => {
              event.target.textContent = originalText;
              event.target.style.background = '';
          }, 2000);
          
          console.log('Settings are automatically synced to VS Code configuration');
      }

      // 加载设置（现在设置从VS Code配置自动加载）
      function loadSettings() {
          // 显示提示 - 设置从 VS Code 配置自动加载
          const originalText = event.target.textContent;
          event.target.textContent = '✅ 已同步';
          event.target.style.background = '#28a745';
          setTimeout(() => {
              event.target.textContent = originalText;
              event.target.style.background = '';
          }, 2000);
          
          console.log('Settings are automatically loaded from VS Code configuration');
      }



      // 修改现有的 getStructureColor 函数以支持主题
      function getStructureColor(structureId) {
          const currentTheme = colorThemes[currentSettings.colorTheme] || colorThemes.default;
          const colors = currentTheme.colors;

          // 为每个结构分配一个固定的颜色索引
          if (!window.structureColorMap) {
              window.structureColorMap = new Map();
              window.structureColorIndex = 0;
          }

          if (!window.structureColorMap.has(structureId)) {
              window.structureColorMap.set(structureId, colors[window.structureColorIndex % colors.length]);
              window.structureColorIndex++;
          }

          return window.structureColorMap.get(structureId);
      }

      // ========== 控制面板折叠和拖拽功能 ==========

      // 切换整个控制面板的折叠状态
      function toggleControlsPanel() {
          const controls = document.getElementById('controls');
          const toggleIcon = document.getElementById('controls-toggle-icon');
          
          controlPanelState.collapsed = !controlPanelState.collapsed;
          
          if (controlPanelState.collapsed) {
              controls.classList.add('collapsed');
              toggleIcon.textContent = '+';
          } else {
              controls.classList.remove('collapsed');
              toggleIcon.textContent = '−';
          }
          
          saveControlPanelState();
          console.log('Controls panel toggled:', controlPanelState.collapsed ? 'collapsed' : 'expanded');
      }

      // 切换控制组的折叠状态
      function toggleControlGroup(headerElement) {
          const controlGroup = headerElement.parentElement;
          const toggleButton = headerElement.querySelector('.control-group-toggle span');
          const h3Text = headerElement.querySelector('h3').textContent;
          
          // 确定组的标识符
          let groupKey = '';
          if (h3Text.includes('View Controls')) {
              groupKey = 'view-controls';
          } else if (h3Text.includes('Structures')) {
              groupKey = 'structures-constraints';
          } else if (h3Text.includes('Statistics')) {
              groupKey = 'statistics';
          }
          
          // 切换状态
          controlPanelState.groupStates[groupKey] = !controlPanelState.groupStates[groupKey];
          const isCollapsed = controlPanelState.groupStates[groupKey];
          
          if (isCollapsed) {
              controlGroup.classList.add('collapsed');
              toggleButton.textContent = '+';
          } else {
              controlGroup.classList.remove('collapsed');
              toggleButton.textContent = '−';
          }
          
          saveControlPanelState();
          console.log(`Control group ${groupKey} toggled:`, isCollapsed ? 'collapsed' : 'expanded');
      }

      // 保存控制面板状态到localStorage
      function saveControlPanelState() {
          try {
              localStorage.setItem('packmolControlPanelState', JSON.stringify(controlPanelState));
          } catch (error) {
              console.warn('Failed to save control panel state:', error);
          }
      }

      // 加载控制面板状态
      function loadControlPanelState() {
          try {
              const saved = localStorage.getItem('packmolControlPanelState');
              if (saved) {
                  controlPanelState = { ...controlPanelState, ...JSON.parse(saved) };
                  applyControlPanelState();
              }
          } catch (error) {
              console.warn('Failed to load control panel state:', error);
          }
      }

      // 应用控制面板状态
      function applyControlPanelState() {
          const controls = document.getElementById('controls');
          const toggleIcon = document.getElementById('controls-toggle-icon');
          
          // 应用位置
          controls.style.left = controlPanelState.position.x + 'px';
          controls.style.top = controlPanelState.position.y + 'px';
          
          // 应用整体折叠状态
          if (controlPanelState.collapsed) {
              controls.classList.add('collapsed');
              toggleIcon.textContent = '+';
          } else {
              controls.classList.remove('collapsed');
              toggleIcon.textContent = '−';
          }
          
          // 应用各组的折叠状态
          setTimeout(() => {
              // 等待DOM完全渲染后再应用组状态
              const controlGroups = document.querySelectorAll('.control-group');
              controlGroups.forEach((group, index) => {
                  const keys = ['view-controls', 'structures-constraints', 'statistics'];
                  const groupKey = keys[index];
                  const isCollapsed = controlPanelState.groupStates[groupKey];
                  const toggleButton = group.querySelector('.control-group-toggle span');
                  
                  if (isCollapsed && toggleButton) {
                      group.classList.add('collapsed');
                      toggleButton.textContent = '+';
                  } else if (toggleButton) {
                      group.classList.remove('collapsed');
                      toggleButton.textContent = '−';
                  }
              });
          }, 100);
      }

      // 初始化拖拽功能
      function initializeControlsDrag() {
          const controlsHeader = document.getElementById('controls-header');
          const controls = document.getElementById('controls');
          
          if (!controlsHeader || !controls) {
              console.warn('Controls header or controls panel not found');
              return;
          }
          
          // 鼠标按下开始拖拽
          controlsHeader.addEventListener('mousedown', (e) => {
              if (e.target.classList.contains('controls-toggle') || 
                  e.target.closest('.controls-toggle')) {
                  return; // 不在切换按钮上开始拖拽
              }
              
              isDragging = true;
              controls.classList.add('dragging');
              
              const rect = controls.getBoundingClientRect();
              dragOffsetX = e.clientX - rect.left;
              dragOffsetY = e.clientY - rect.top;
              
              // 阻止文本选择
              e.preventDefault();
              
              console.log('Started dragging controls panel');
          });
          
          // 鼠标移动
          document.addEventListener('mousemove', (e) => {
              if (!isDragging) return;
              
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              const controlsRect = controls.getBoundingClientRect();
              
              // 计算新位置，确保不超出视窗边界
              let newX = e.clientX - dragOffsetX;
              let newY = e.clientY - dragOffsetY;
              
              // 边界检查
              newX = Math.max(0, Math.min(newX, viewportWidth - controlsRect.width));
              newY = Math.max(0, Math.min(newY, viewportHeight - controlsRect.height));
              
              controls.style.left = newX + 'px';
              controls.style.top = newY + 'px';
              
              // 更新状态
              controlPanelState.position.x = newX;
              controlPanelState.position.y = newY;
          });
          
          // 鼠标释放结束拖拽
          document.addEventListener('mouseup', () => {
              if (isDragging) {
                  isDragging = false;
                  controls.classList.remove('dragging');
                  saveControlPanelState();
                  console.log('Ended dragging controls panel at:', controlPanelState.position);
              }
          });
          
          // 触摸设备支持
          controlsHeader.addEventListener('touchstart', (e) => {
              if (e.target.classList.contains('controls-toggle') || 
                  e.target.closest('.controls-toggle')) {
                  return;
              }
              
              const touch = e.touches[0];
              isDragging = true;
              controls.classList.add('dragging');
              
              const rect = controls.getBoundingClientRect();
              dragOffsetX = touch.clientX - rect.left;
              dragOffsetY = touch.clientY - rect.top;
              
              e.preventDefault();
          });
          
          document.addEventListener('touchmove', (e) => {
              if (!isDragging) return;
              
              const touch = e.touches[0];
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              const controlsRect = controls.getBoundingClientRect();
              
              let newX = touch.clientX - dragOffsetX;
              let newY = touch.clientY - dragOffsetY;
              
              newX = Math.max(0, Math.min(newX, viewportWidth - controlsRect.width));
              newY = Math.max(0, Math.min(newY, viewportHeight - controlsRect.height));
              
              controls.style.left = newX + 'px';
              controls.style.top = newY + 'px';
              
              controlPanelState.position.x = newX;
              controlPanelState.position.y = newY;
              
              e.preventDefault();
          });
          
          document.addEventListener('touchend', () => {
              if (isDragging) {
                  isDragging = false;
                  controls.classList.remove('dragging');
                  saveControlPanelState();
              }
          });
          
          console.log('✅ Controls drag functionality initialized');
      }

      // 启动初始化
      console.log('🏁 Starting initialization sequence...');

      // 立即测试连接
      testVSCodeConnection();

      // 检查 DOM 状态并开始初始化
      function startInitialization() {
          console.log('📋 DOM ready, starting Three.js check...');
          // 短暂延迟以确保脚本标签有时间加载
          setTimeout(() => {
              checkThreeJS();
          }, 100);
      }

      // 等待 DOM 加载
      if (document.readyState === 'loading') {
          console.log('⏳ DOM still loading, waiting for DOMContentLoaded...');
          document.addEventListener('DOMContentLoaded', startInitialization);
      } else {
          console.log('✅ DOM already loaded');
          startInitialization();
      }

      // 备用方案：如果在 5 秒内还没有初始化，强制发送 ready 消息
      setTimeout(() => {
          if (!isThreeJSReady && vscode) {
              console.log('⚠️ Fallback: Sending ready message after timeout');
              sendReadyMessage();
          }
      }, 5000);
    </script>

    <!-- 在最后添加 Three.js 脚本，确保 DOM 先加载 -->
    <script
      src="${threeJsUri}"
      onerror="console.error('❌ Failed to load Three.js from CDN'); document.getElementById('loading').innerHTML = 'Error: Failed to load Three.js';"
      onload="console.log('✅ Three.js script loaded from CDN');"
    ></script>
  </body>
</html>
