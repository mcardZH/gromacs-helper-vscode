<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Packmol 3D Preview</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #1e1e1e;
        color: #cccccc;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #canvas-container {
        width: 100%;
        height: 100%;
      }

      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(30, 30, 30, 0.95);
        padding: 0;
        border-radius: 8px;
        max-width: 280px;
        min-width: 200px;
        max-height: calc(100vh - 40px);
        overflow: visible;
        border: 1px solid #555;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      }

      #controls.dragging {
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        transform: scale(1.02);
      }

      .controls-header {
        background: rgba(0, 102, 204, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 8px 8px 0 0;
        cursor: move;
        display: flex;
        justify-content: space-between;
        align-items: center;
        -webkit-user-select: none;
        user-select: none;
        font-weight: bold;
        font-size: 13px;
      }

      .controls-header:hover {
        background: rgba(0, 82, 163, 0.9);
      }

      .controls-content {
        padding: 10px;
        max-height: calc(100vh - 100px);
        overflow-y: auto;
      }

      .controls-toggle {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        padding: 0;
        width: 20px;
        height: 20px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
      }

      .controls-toggle:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      #controls.collapsed .controls-content {
        display: none;
      }

      #controls.collapsed {
        border-radius: 8px;
      }

      .control-group {
        margin-bottom: 15px;
        border: 1px solid transparent;
        border-radius: 6px;
        transition: all 0.3s ease;
      }

      .control-group:hover {
        border-color: #444;
        background: rgba(255, 255, 255, 0.02);
      }

      .control-group-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        -webkit-user-select: none;
        user-select: none;
        padding: 4px 8px;
        border-radius: 4px;
        transition: background-color 0.2s;
      }

      .control-group-header:hover {
        background: rgba(255, 255, 255, 0.05);
      }

      .control-group h3 {
        margin: 0;
        font-size: 14px;
        color: #ffffff;
        flex: 1;
        padding-bottom: 0;
        border-bottom: none;
      }

      .control-group-toggle {
        background: none;
        border: none;
        color: #ccc;
        font-size: 12px;
        cursor: pointer;
        padding: 2px 4px;
        border-radius: 3px;
        transition: all 0.2s;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .control-group-toggle:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      .control-group-content {
        margin-top: 8px;
        padding-left: 4px;
        border-left: 2px solid #444;
        margin-left: 4px;
        transition: all 0.3s ease;
        overflow: hidden;
      }

      .control-group.collapsed .control-group-content {
        max-height: 0;
        margin-top: 0;
        opacity: 0;
        transform: translateY(-10px);
      }

      .control-group:not(.collapsed) .control-group-content {
        max-height: 1000px;
        opacity: 1;
        transform: translateY(0);
      }

      .structure-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        font-size: 12px;
        padding: 2px 0;
      }

      .structure-checkbox {
        margin-right: 8px;
        flex-shrink: 0;
      }

      .structure-info {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .structure-count {
        color: #888;
        margin-left: 5px;
      }

      .structure-color-picker {
        width: 20px;
        height: 20px;
        border: 1px solid #555;
        border-radius: 3px;
        cursor: pointer;
        margin-left: 8px;
        flex-shrink: 0;
      }

      .structure-color-picker::-webkit-color-swatch {
        border: none;
        border-radius: 2px;
      }

      .structure-color-picker::-webkit-color-swatch-wrapper {
        padding: 0;
      }

      .button {
        background: #0066cc;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin: 2px;
        transition: all 0.2s ease;
        white-space: nowrap;
        flex-shrink: 0;
      }

      .button:hover {
        background: #0052a3;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 102, 204, 0.3);
      }

      .button:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 102, 204, 0.3);
      }

      /* æŠ˜å çŠ¶æ€ä¸‹çš„æ§åˆ¶é¢æ¿ä¼˜åŒ– */
      #controls.collapsed {
        min-width: auto;
        width: auto;
      }

      #controls.collapsed .controls-header {
        border-radius: 8px;
        padding: 6px 10px;
      }

      /* å“åº”å¼è®¾è®¡ - å°å±å¹•ä¼˜åŒ– */
      @media (max-width: 768px) {
        #controls {
          max-width: calc(100vw - 20px);
          font-size: 11px;
        }
        
        .button {
          padding: 4px 8px;
          font-size: 11px;
          margin: 1px;
        }
        
        .controls-header {
          padding: 6px 8px;
          font-size: 12px;
        }
        
        .control-group h3 {
          font-size: 13px;
        }
      }

      /* æ‹–æ‹½æ—¶çš„è§†è§‰åé¦ˆå¢å¼º */
      #controls.dragging {
        transition: none;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.6);
        transform: scale(1.02) rotate(1deg);
        z-index: 1000;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #cccccc;
        font-size: 16px;
      }

      .error {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ff6b6b;
        font-size: 14px;
        text-align: center;
        max-width: 300px;
      }

      #info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(30, 30, 30, 0.9);
        padding: 8px;
        border-radius: 3px;
        font-size: 11px;
        color: #aaa;
      }

      .surface-slider-container {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 2px 0;
      }

      .surface-slider {
        width: 100px;
        height: 18px;
        background: #444;
        border-radius: 9px;
        outline: none;
        cursor: pointer;
      }

      .surface-slider::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #0066cc;
        cursor: pointer;
        border: 2px solid #ffffff;
      }

      .surface-slider::-webkit-slider-thumb:hover {
        background: #0052a3;
      }

      .surface-slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #0066cc;
        cursor: pointer;
        border: 2px solid #ffffff;
      }

      /* è®¾ç½®é¢æ¿æ ·å¼ */
      .settings-panel {
        display: none;
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 101;
        background: rgba(30, 30, 30, 0.95);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #555;
        min-width: 280px;
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .settings-panel.visible {
        display: block;
      }

      .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 1px solid #444;
      }

      .settings-title {
        font-size: 16px;
        font-weight: bold;
        color: #ffffff;
      }

      .close-settings {
        background: #666;
        color: white;
        border: none;
        padding: 4px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
      }

      .close-settings:hover {
        background: #888;
      }

      .settings-button {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        background: rgba(0, 102, 204, 0.9);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
      }

      .settings-button:hover {
        background: rgba(0, 82, 163, 0.9);
      }

      .setting-item {
        margin-bottom: 15px;
      }

      .setting-label {
        display: block;
        margin-bottom: 5px;
        font-size: 13px;
        color: #ccc;
        font-weight: 500;
      }

      .setting-input {
        width: 100%;
        padding: 6px 8px;
        background: #2a2a2a;
        border: 1px solid #555;
        border-radius: 4px;
        color: #fff;
        font-size: 12px;
      }

      .setting-input:focus {
        outline: none;
        border-color: #0066cc;
      }

      .setting-slider {
        width: 100%;
        height: 20px;
        background: #444;
        border-radius: 10px;
        outline: none;
        cursor: pointer;
      }

      .setting-slider::-webkit-slider-thumb {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0066cc;
        cursor: pointer;
        border: 2px solid #ffffff;
      }

      .setting-slider::-webkit-slider-thumb:hover {
        background: #0052a3;
      }

      .setting-value {
        display: inline-block;
        margin-left: 8px;
        font-size: 11px;
        color: #aaa;
        min-width: 30px;
      }

      .theme-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-top: 5px;
      }

      .theme-option {
        padding: 8px;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 6px;
        cursor: pointer;
        text-align: center;
        font-size: 11px;
        color: #ccc;
        transition: all 0.2s;
      }

      .theme-option.active {
        border-color: #0066cc;
        background: #0066cc20;
        color: #fff;
      }

      .theme-option:hover {
        border-color: #666;
        background: #333;
      }

      .theme-colors {
        display: flex;
        justify-content: center;
        gap: 2px;
        margin-top: 4px;
      }

      .theme-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
        border: 1px solid #555;
      }

      .color-preset-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 4px;
        margin-top: 5px;
      }

      .color-preset {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        cursor: pointer;
        border: 2px solid transparent;
        transition: border-color 0.2s;
      }

      .color-preset:hover {
        border-color: #666;
      }

      .color-preset.active {
        border-color: #0066cc;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="canvas-container"></div>

      <div id="controls">
        <div class="controls-header" id="controls-header">
          <div>ğŸ›ï¸ Control Panel</div>
          <button class="controls-toggle" onclick="toggleControlsPanel()" title="æŠ˜å /å±•å¼€é¢æ¿">
            <span id="controls-toggle-icon">âˆ’</span>
          </button>
        </div>
        <div class="controls-content">
          <div class="control-group">
            <div class="control-group-header" onclick="toggleControlGroup(this)">
              <h3>ğŸ® View Controls</h3>
              <button class="control-group-toggle" title="æŠ˜å /å±•å¼€">
                <span>âˆ’</span>
              </button>
            </div>
            <div class="control-group-content">
              <button class="button" onclick="resetCamera()">Reset Camera</button>
              <button class="button" onclick="toggleWireframe()">
                Toggle Wireframe
              </button>
              <button class="button" onclick="toggleMultisphere()">
                Toggle Multisphere
              </button>
              <button class="button" onclick="toggleSurfaceArrows()">
                Toggle Surface Arrows
              </button>
              <button class="button" onclick="randomizeColors()">
                Random Colors
              </button>
              <button class="button" onclick="resetColors()">Reset Colors</button>
            </div>
          </div>

          <div class="control-group">
            <div class="control-group-header" onclick="toggleControlGroup(this)">
              <h3>ğŸ“¦ Structures & Constraints</h3>
              <button class="control-group-toggle" title="æŠ˜å /å±•å¼€">
                <span>âˆ’</span>
              </button>
            </div>
            <div class="control-group-content">
              <div id="structure-list"></div>
            </div>
          </div>

          <div class="control-group">
            <div class="control-group-header" onclick="toggleControlGroup(this)">
              <h3>ğŸ“Š Statistics</h3>
              <button class="control-group-toggle" title="æŠ˜å /å±•å¼€">
                <span>âˆ’</span>
              </button>
            </div>
            <div class="control-group-content">
              <div id="constraint-list"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- è®¾ç½®æŒ‰é’® -->
      <button class="settings-button" onclick="toggleSettings()">âš™ï¸ Settings</button>

      <!-- è®¾ç½®é¢æ¿ -->
      <div id="settings-panel" class="settings-panel">
        <div class="settings-header">
          <div class="settings-title">âš™ï¸ å¯è§†åŒ–è®¾ç½®</div>
          <button class="close-settings" onclick="toggleSettings()">âœ•</button>
        </div>

        <!-- é¢œè‰²ä¸»é¢˜ -->
        <div class="setting-item">
          <label class="setting-label">ğŸ¨ é¢œè‰²ä¸»é¢˜</label>
          <div class="theme-grid" id="theme-grid">
            <!-- ä¸»é¢˜é€‰é¡¹å°†é€šè¿‡ JavaScript åŠ¨æ€ç”Ÿæˆ -->
          </div>
        </div>

        <!-- å‡ ä½•ä½“åˆ†æ®µæ•°è®¾ç½® -->
        <div class="setting-item">
          <label class="setting-label">ğŸ”— è¿çº¿å¯†åº¦</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="segments-slider" 
                   min="8" max="64" step="2" value="16" 
                   oninput="updateGeometrySegments(this.value)">
            <span class="setting-value" id="segments-value">16</span>
          </div>
          <div style="font-size: 10px; color: #888; margin-top: 2px;">
            è°ƒæ•´å‡ ä½•ä½“çš„åˆ†æ®µæ•°ï¼Œæ•°å€¼è¶Šå¤§è¿çº¿è¶Šå¯†é›†
          </div>
        </div>

        <!-- é€æ˜åº¦è®¾ç½® -->
        <div class="setting-item">
          <label class="setting-label">ğŸ” ç»“æ„é€æ˜åº¦</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="opacity-slider" 
                   min="0.1" max="1.0" step="0.05" value="0.6" 
                   oninput="updateOpacity(this.value)">
            <span class="setting-value" id="opacity-value">0.60</span>
          </div>
        </div>

        <!-- çº¦æŸé€æ˜åº¦è®¾ç½® -->
        <div class="setting-item">
          <label class="setting-label">ğŸ“ çº¦æŸé€æ˜åº¦</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="constraint-opacity-slider" 
                   min="0.1" max="1.0" step="0.05" value="0.3" 
                   oninput="updateConstraintOpacity(this.value)">
            <span class="setting-value" id="constraint-opacity-value">0.30</span>
          </div>
        </div>

        <!-- èƒŒæ™¯é¢œè‰² -->
        <div class="setting-item">
          <label class="setting-label">ğŸŒŒ èƒŒæ™¯é¢œè‰²</label>
          <div class="color-preset-grid" id="background-presets">
            <!-- èƒŒæ™¯è‰²é¢„è®¾å°†é€šè¿‡ JavaScript åŠ¨æ€ç”Ÿæˆ -->
          </div>
          <input type="color" class="setting-input" id="background-color" 
                 value="#1e1e1e" onchange="updateBackgroundColor(this.value)"
                 style="margin-top: 8px; height: 32px;">
        </div>

        <!-- å…‰ç…§å¼ºåº¦ -->
        <div class="setting-item">
          <label class="setting-label">ğŸ’¡ ç¯å¢ƒå…‰å¼ºåº¦</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="ambient-light-slider" 
                   min="0.1" max="1.5" step="0.1" value="0.6" 
                   oninput="updateAmbientLight(this.value)">
            <span class="setting-value" id="ambient-light-value">0.6</span>
          </div>
        </div>

        <!-- æ–¹å‘å…‰å¼ºåº¦ -->
        <div class="setting-item">
          <label class="setting-label">ğŸ”† æ–¹å‘å…‰å¼ºåº¦</label>
          <div style="display: flex; align-items: center;">
            <input type="range" class="setting-slider" id="directional-light-slider" 
                   min="0.1" max="2.0" step="0.1" value="0.8" 
                   oninput="updateDirectionalLight(this.value)">
            <span class="setting-value" id="directional-light-value">0.8</span>
          </div>
        </div>

        <!-- é‡ç½®æŒ‰é’® -->
        <div class="setting-item">
          <button class="button" onclick="resetSettings()" style="width: 100%;">
            ğŸ”„ é‡ç½®æ‰€æœ‰è®¾ç½®
          </button>
        </div>

        <!-- ä¿å­˜/åŠ è½½è®¾ç½® -->
        <div class="setting-item">
          <div style="display: flex; gap: 8px;">
            <button class="button" onclick="saveSettings()" style="flex: 1;">
              ğŸ’¾ ä¿å­˜è®¾ç½®
            </button>
            <button class="button" onclick="loadSettings()" style="flex: 1;">
              ğŸ“ åŠ è½½è®¾ç½®
            </button>
          </div>
        </div>
      </div>

      <div id="info">Mouse: Left=Rotate, Right=Pan, Wheel=Zoom</div>

      <div id="loading" class="loading">Loading...</div>
    </div>

    <script>
      console.log('ğŸš€ Webview script starting...');

      // å…¨å±€å˜é‡
      let scene, camera, renderer, controls;
      let structureGroups = new Map();
      let constraintGroups = new Map();
      let currentData = null;
      let wireframeMode = false;
      let isThreeJSReady = false;
      let initializationAttempts = 0;
      const MAX_INIT_ATTEMPTS = 20;
      // å­˜å‚¨è¡¨é¢çº¦æŸçš„å¤§å°å‚æ•°
      let surfaceConstraintSizes = new Map();
      
      // æ§åˆ¶é¢æ¿ç›¸å…³å˜é‡
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let controlPanelState = {
        collapsed: false,
        position: { x: 10, y: 10 },
        groupStates: {
          'view-controls': false,
          'structures-constraints': false,
          'statistics': false
        }
      };
      
      // è®¾ç½®ç›¸å…³å…¨å±€å˜é‡
      let ambientLight, directionalLight;
      let currentSettings = {
        geometrySegments: 16,  // å‡ ä½•ä½“åˆ†æ®µæ•°ï¼ˆæ§åˆ¶è¿çº¿æ•°é‡ï¼‰
        structureOpacity: 0.6,
        constraintOpacity: 0.3,
        backgroundColor: '#1e1e1e',
        ambientLightIntensity: 0.6,
        directionalLightIntensity: 0.8,
        colorTheme: 'default'
      };

      // é¢œè‰²ä¸»é¢˜å®šä¹‰
      const colorThemes = {
        'default': {
          name: 'é»˜è®¤',
          colors: [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeaa7, 0xdda0dd, 0x74b9ff, 0xfd79a8, 0xa29bfe, 0x6c5ce7]
        },
        'warm': {
          name: 'æš–è‰²è°ƒ',
          colors: [0xff7675, 0xfd79a8, 0xe17055, 0xf39c12, 0xe74c3c, 0x9b59b6, 0x8e44ad, 0x3f3f3f, 0x34495e, 0x2c3e50]
        },
        'cool': {
          name: 'å†·è‰²è°ƒ',
          colors: [0x00b894, 0x00cec9, 0x0984e3, 0x74b9ff, 0x6c5ce7, 0xa29bfe, 0x81ecec, 0x55a3ff, 0x2d3436, 0x636e72]
        },
        'pastel': {
          name: 'æŸ”å’Œè‰²',
          colors: [0xfab1a0, 0xffeaa7, 0xbadc58, 0x6c5ce7, 0xa29bfe, 0xfd79a8, 0x74b9ff, 0x00b894, 0xe17055, 0x636e72]
        },
        'monochrome': {
          name: 'å•è‰²è°ƒ',
          colors: [0xffffff, 0xe6e6e6, 0xcccccc, 0xb3b3b3, 0x999999, 0x808080, 0x666666, 0x4d4d4d, 0x333333, 0x1a1a1a]
        },
        'vibrant': {
          name: 'é²œè‰³è‰²',
          colors: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8000, 0x8000ff, 0x00ff80, 0xff0080]
        }
      };

      // èƒŒæ™¯è‰²é¢„è®¾
      const backgroundPresets = [
        { name: 'æ·±ç°', color: '#1e1e1e' },
        { name: 'é»‘è‰²', color: '#000000' },
        { name: 'æ·±è“', color: '#0f1419' },
        { name: 'ç™½è‰²', color: '#ffffff' },
        { name: 'æµ…ç°', color: '#f5f5f5' }
      ];

      // VS Code API
      let vscode;
      try {
          vscode = acquireVsCodeApi();
          console.log('âœ… VS Code API acquired successfully');
      } catch (error) {
          console.error('âŒ Failed to acquire VS Code API:', error);
          document.getElementById('loading').innerHTML = 'Error: Cannot acquire VS Code API';
      }

      // ç«‹å³å°è¯•å‘é€ä¸€ä¸ªæµ‹è¯•æ¶ˆæ¯æ¥éªŒè¯è¿æ¥
      function testVSCodeConnection() {
          console.log('ğŸ§ª Testing VS Code connection...');
          if (vscode) {
              try {
                  vscode.postMessage({ type: 'test', message: 'Webview loaded' });
                  console.log('âœ… Test message sent successfully');
              } catch (error) {
                  console.error('âŒ Failed to send test message:', error);
              }
          }
      }

      // åœ¨æ²¡æœ‰ Three.js çš„æƒ…å†µä¸‹ä¹Ÿè¦å‘é€ ready æ¶ˆæ¯
      function sendReadyMessage() {
          console.log('ğŸ“¤ Sending ready message to VS Code...');
          if (vscode) {
              try {
                  vscode.postMessage({ type: 'ready' });
                  console.log('âœ… Ready message sent successfully');
                  document.getElementById('loading').innerHTML = 'Ready! Waiting for data...';
              } catch (error) {
                  console.error('âŒ Failed to send ready message:', error);
                  document.getElementById('loading').innerHTML = 'Error sending ready message';
              }
          } else {
              console.error('âŒ Cannot send ready message - vscode API not available');
              document.getElementById('loading').innerHTML = 'Error: VS Code API not available';
          }
      }

      // æ£€æŸ¥ Three.js æ˜¯å¦åŠ è½½
      function checkThreeJS() {
          initializationAttempts++;
          console.log(`ğŸ” Checking Three.js (attempt ${initializationAttempts}/${MAX_INIT_ATTEMPTS})...`);

          if (typeof THREE !== 'undefined') {
              console.log('âœ… Three.js loaded successfully');
              initThreeJS();
          } else if (initializationAttempts < MAX_INIT_ATTEMPTS) {
              console.log('â³ Three.js not yet loaded, retrying in 200ms...');
              setTimeout(checkThreeJS, 200);
          } else {
              console.error('âŒ Three.js failed to load after maximum attempts');
              document.getElementById('loading').innerHTML = 'Error: Three.js failed to load. Using fallback mode.';
              // å³ä½¿ Three.js å¤±è´¥ï¼Œä¹Ÿè¦å‘é€ ready æ¶ˆæ¯
              sendReadyMessage();
          }
      }

      // åˆå§‹åŒ– Three.js åœºæ™¯
      function initThreeJS() {
          console.log('ğŸ¨ Initializing Three.js...');
          const container = document.getElementById('canvas-container');

          if (!container) {
              console.error('âŒ Canvas container not found');
              document.getElementById('loading').innerHTML = 'Error: Canvas container not found';
              return;
          }

          try {
              // åœºæ™¯
              scene = new THREE.Scene();
              scene.background = new THREE.Color(currentSettings.backgroundColor);
              console.log('âœ… Scene created');

              // ç›¸æœº
              const aspect = container.clientWidth / container.clientHeight || 1;
              camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
              camera.position.set(50, 50, 50);
              camera.lookAt(0, 0, 0);
              console.log('âœ… Camera created');

              // æ¸²æŸ“å™¨
              renderer = new THREE.WebGLRenderer({ antialias: true });
              renderer.setSize(container.clientWidth || 400, container.clientHeight || 300);
              renderer.shadowMap.enabled = true;
              renderer.shadowMap.type = THREE.PCFSoftShadowMap;
              container.appendChild(renderer.domElement);
              console.log('âœ… Renderer created and added to DOM');

              // æ§åˆ¶å™¨ (ç®€åŒ–ç‰ˆæœ¬ï¼Œä¸ä¾èµ– OrbitControls)
              setupSimpleControls();
              console.log('âœ… Controls setup complete');

              // å…‰ç…§
              ambientLight = new THREE.AmbientLight(0x404040, currentSettings.ambientLightIntensity);
              scene.add(ambientLight);

              directionalLight = new THREE.DirectionalLight(0xffffff, currentSettings.directionalLightIntensity);
              directionalLight.position.set(100, 100, 50);
              directionalLight.castShadow = true;
              directionalLight.shadow.mapSize.width = 2048;
              directionalLight.shadow.mapSize.height = 2048;
              scene.add(directionalLight);
              console.log('âœ… Lights added');

              // åæ ‡è½´
              const axesHelper = new THREE.AxesHelper(10);
              scene.add(axesHelper);

              // æ¸²æŸ“å¾ªç¯
              animate();
              console.log('âœ… Animation loop started');

              // çª—å£è°ƒæ•´
              window.addEventListener('resize', onWindowResize);
              console.log('âœ… Resize listener added');

              // æ ‡è®°ä¸ºå‡†å¤‡å°±ç»ª
              isThreeJSReady = true;
              console.log('ğŸ‰ Three.js initialization complete!');

              // åˆå§‹åŒ–è®¾ç½®ç•Œé¢
              initializeSettings();

              // åˆå§‹åŒ–æ§åˆ¶é¢æ¿åŠŸèƒ½
              loadControlPanelState();
              initializeControlsDrag();

              // å‘é€å‡†å¤‡å°±ç»ªæ¶ˆæ¯
              sendReadyMessage();

              // éšè—åŠ è½½æŒ‡ç¤ºå™¨
              document.getElementById('loading').style.display = 'none';

          } catch (error) {
              console.error('âŒ Error initializing Three.js:', error);
              document.getElementById('loading').innerHTML = 'Error initializing 3D scene: ' + error.message;
              // å³ä½¿åˆå§‹åŒ–å¤±è´¥ï¼Œä¹Ÿè¦å‘é€ ready æ¶ˆæ¯
              sendReadyMessage();
          }
      }

      // ç®€å•çš„é¼ æ ‡æ§åˆ¶
      function setupSimpleControls() {
          let isMouseDown = false;
          let mouseButton = -1;
          let mouseX = 0, mouseY = 0;

          renderer.domElement.addEventListener('mousedown', (event) => {
              isMouseDown = true;
              mouseButton = event.button;
              mouseX = event.clientX;
              mouseY = event.clientY;
          });

          renderer.domElement.addEventListener('mouseup', () => {
              isMouseDown = false;
          });

          renderer.domElement.addEventListener('mousemove', (event) => {
              if (!isMouseDown) return;

              const deltaX = event.clientX - mouseX;
              const deltaY = event.clientY - mouseY;

              if (mouseButton === 0) { // å·¦é”®æ—‹è½¬
                  const spherical = new THREE.Spherical();
                  spherical.setFromVector3(camera.position);
                  spherical.theta -= deltaX * 0.01;
                  spherical.phi += deltaY * 0.01;
                  spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                  camera.position.setFromSpherical(spherical);
                  camera.lookAt(0, 0, 0);
              } else if (mouseButton === 2) { // å³é”®å¹³ç§»
                  const panSpeed = 0.1;
                  camera.position.x += deltaX * panSpeed;
                  camera.position.y -= deltaY * panSpeed;
              }

              mouseX = event.clientX;
              mouseY = event.clientY;
          });

          renderer.domElement.addEventListener('wheel', (event) => {
              const zoomSpeed = 0.1;
              const direction = camera.position.clone().normalize();
              if (event.deltaY > 0) {
                  camera.position.add(direction.multiplyScalar(zoomSpeed * camera.position.length()));
              } else {
                  camera.position.sub(direction.multiplyScalar(zoomSpeed * camera.position.length()));
              }
          });

          renderer.domElement.addEventListener('contextmenu', (event) => {
              event.preventDefault();
          });
      }

      // çª—å£å¤§å°è°ƒæ•´
      function onWindowResize() {
          const container = document.getElementById('canvas-container');
          camera.aspect = container.clientWidth / container.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(container.clientWidth, container.clientHeight);
      }

      // åŠ¨ç”»å¾ªç¯
      function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
      }

      // æ›´æ–°æ•°æ®
      function updateData(data) {
          console.log('ğŸ”„ === updateData START ===');
          console.log('Input data:', data);
          console.log('Three.js ready:', isThreeJSReady);
          console.log('Scene exists:', !!scene);
          console.log('Camera exists:', !!camera);

          if (!isThreeJSReady) {
              console.error('âŒ Three.js not ready for updateData');
              alert('Three.js æœªå‡†å¤‡å¥½ï¼Œæ— æ³•æ›´æ–°æ•°æ®');
              return;
          }

          try {
              currentData = data;
              
              // å¦‚æœæ”¶åˆ°äº†é…ç½®æ•°æ®ï¼Œåº”ç”¨å®ƒä»¬
              if (data.settings) {
                  console.log('ğŸ“ Applying settings from extension:', data.settings);
                  applySettingsFromExtension(data.settings);
              }
                   // æ¸…é™¤ç°æœ‰çš„ç»“æ„
          console.log('ğŸ§¹ Clearing existing structures...');
          console.log('Structure groups count:', structureGroups.size);
          console.log('Constraint groups count:', constraintGroups.size);

          structureGroups.forEach(group => {
              console.log('Removing group:', group.name);
              scene.remove(group);
          });
          structureGroups.clear();
          constraintGroups.clear(); // çº¦æŸç°åœ¨æ˜¯ç»“æ„çš„å­å¯¹è±¡ï¼Œä¼šéšç»“æ„ä¸€èµ·åˆ é™¤

              // åˆ›å»ºç»“æ„
              if (data.input && data.input.structures) {
                  console.log('ğŸ—ï¸ Creating structures for:', data.input.structures.length, 'structures');

                  // æ£€æŸ¥å¤šçƒæ•°æ®
                  const multisphereStructures = data.input.structures.filter(s =>
                      s.visualInfo && s.visualInfo.geometry && s.visualInfo.geometry.type === 'multi_sphere'
                  );
                  console.log('ğŸ”® Found', multisphereStructures.length, 'structures with multisphere geometry');

                  multisphereStructures.forEach((structure, i) => {
                      const sphereCount = structure.visualInfo.geometry.spheres?.length || 0;
                      console.log('ğŸ”® Multisphere structure', i + 1, ':', structure.filename, 'with', sphereCount, 'spheres');
                      if (structure.visualInfo.geometry.spheres) {
                          structure.visualInfo.geometry.spheres.forEach((sphere, j) => {
                              console.log('  Sphere', j + 1, ':', sphere.center, 'radius=', sphere.radius);
                          });
                      }
                  });

                  data.input.structures.forEach((structure, index) => {
                      console.log('ğŸ“¦ Creating structure ' + index + ':', structure.filename, 'number=' + structure.number);

                      // è¯¦ç»†æ£€æŸ¥ç»“æ„çš„å¯è§†åŒ–ä¿¡æ¯
                      if (structure.visualInfo) {
                          console.log('  ğŸ“Š VisualInfo type:', structure.visualInfo.type);
                          if (structure.visualInfo.geometry) {
                              console.log('  ğŸ”® Geometry type:', structure.visualInfo.geometry.type);
                              if (structure.visualInfo.geometry.type === 'multi_sphere') {
                                  console.log('  ğŸ¯ MULTISPHERE DETECTED! Spheres:', structure.visualInfo.geometry.spheres?.length || 0);
                              }
                          }
                      } else {
                          console.warn('  âŒ No visualInfo found for structure:', structure.filename);
                      }

                      try {
                          createStructureVisualization(structure);
                          console.log('âœ… Structure ' + index + ' created successfully');
                      } catch (structError) {
                          console.error('âŒ Error creating structure ' + index + ':', structError);
                      }
                  });
              } else {
                  console.warn('âš ï¸ No structures found in data');
                  console.log('Data.input:', data.input);
              }

              // æ›´æ–°æ§åˆ¶é¢æ¿
              console.log('ğŸ›ï¸ Updating control panel...');
              updateControlPanel();

              // è°ƒæ•´ç›¸æœºä½ç½®
              console.log('ğŸ“· Fitting camera to scene...');
              fitCameraToScene();

              console.log('âœ… === updateData COMPLETE ===');
              // alert('æ•°æ®æ›´æ–°å®Œæˆï¼ç»“æ„æ•°é‡: ' + (data.input?.structures?.length || 0));

          } catch (error) {
              console.error('âŒ === updateData ERROR ===');
              console.error('Error details:', error);
              // alert('updateData å‡ºé”™: ' + error.message);
          }
      }

      // åˆ›å»ºå¤šçƒæ‹Ÿåˆå¯è§†åŒ–
      function createMultisphereVisualization(structure, group) {
          console.log('Creating multisphere visualization for:', structure.id);

          // æ£€æŸ¥æ˜¯å¦æœ‰å¤šçƒå‡ ä½•ä½“æ•°æ®
          if (structure.visualInfo && structure.visualInfo.geometry &&
              structure.visualInfo.geometry.type === 'multi_sphere' &&
              structure.visualInfo.geometry.spheres) {

              const spheres = structure.visualInfo.geometry.spheres;
              console.log('Creating ' + spheres.length + ' spheres for structure:', structure.id);

              const structureColor = getStructureColor(structure.id);

              // åˆ›å»ºæ¯ä¸ªçƒä½“
              spheres.forEach((sphere, index) => {
                  const sphereGeometry = new THREE.SphereGeometry(sphere.radius, currentSettings.geometrySegments, currentSettings.geometrySegments);

                  // ä¸ºä¸åŒçš„çƒä½“ä½¿ç”¨ç•¥å¾®ä¸åŒçš„é¢œè‰²
                  const color = new THREE.Color(structureColor);
                  const hsl = {};
                  color.getHSL(hsl);

                  // è°ƒæ•´è‰²è°ƒå’Œé¥±å’Œåº¦æ¥åŒºåˆ†ä¸åŒçš„çƒä½“
                  hsl.h = (hsl.h + index * 0.1) % 1.0;
                  hsl.s = Math.min(1.0, hsl.s + index * 0.05);
                  color.setHSL(hsl.h, hsl.s, hsl.l);

                  const sphereMaterial = new THREE.MeshLambertMaterial({
                      color: color,
                      transparent: true,
                      opacity: currentSettings.structureOpacity,
                      wireframe: false
                  });

                  const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                  sphereMesh.position.set(sphere.center[0], sphere.center[1], sphere.center[2]);
                  sphereMesh.name = structure.id + '_multisphere_' + index;

                  // æ·»åŠ çƒä½“è¾¹æ¡†ï¼ˆçº¿æ¡†ï¼‰
                  const wireframeGeometry = new THREE.SphereGeometry(sphere.radius, Math.max(8, currentSettings.geometrySegments / 2), Math.max(8, currentSettings.geometrySegments / 2));
                  const wireframeMaterial = new THREE.MeshBasicMaterial({
                      color: structureColor,
                      wireframe: true,
                      transparent: true,
                      opacity: 0.4
                  });
                  const wireframeMesh = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
                  wireframeMesh.position.set(sphere.center[0], sphere.center[1], sphere.center[2]);
                  wireframeMesh.name = structure.id + '_multisphere_wireframe_' + index;

                  group.add(sphereMesh);
                  group.add(wireframeMesh);

                  console.log('Added sphere ' + index + ': center=(' + sphere.center.join(', ') + '), radius=' + sphere.radius.toFixed(2));
              });

              // æ·»åŠ è¿æ¥çº¿æ¥æ˜¾ç¤ºçƒä½“ä¹‹é—´çš„å…³ç³»
              if (spheres.length > 1) {
                  createSphereBonds(spheres, group, structureColor);
              }

              // æ·»åŠ è´¨å¿ƒæ ‡è®°
              const centroid = calculateSphereCentroid(spheres);
              const centroidSegments = Math.max(6, Math.floor(currentSettings.geometrySegments / 3));
              const centroidGeometry = new THREE.SphereGeometry(0.8, centroidSegments, centroidSegments);
              const centroidMaterial = new THREE.MeshBasicMaterial({
                  color: structureColor,
                  transparent: true,
                  opacity: 0.9
              });
              const centroidMesh = new THREE.Mesh(centroidGeometry, centroidMaterial);
              centroidMesh.position.set(centroid[0], centroid[1], centroid[2]);
              centroidMesh.name = structure.id + '_centroid';
              group.add(centroidMesh);

              console.log('Multisphere visualization created with ' + spheres.length + ' spheres');
              return true;
          }

          return false;
      }

      // åˆ›å»ºçƒä½“ä¹‹é—´çš„è¿æ¥çº¿
      function createSphereBonds(spheres, group, color) {
          const bondMaterial = new THREE.LineBasicMaterial({
              color: color,
              transparent: true,
              opacity: currentSettings.constraintOpacity
          });

          // è¿æ¥ç›¸è¿‘çš„çƒä½“
          for (let i = 0; i < spheres.length; i++) {
              for (let j = i + 1; j < spheres.length; j++) {
                  const sphere1 = spheres[i];
                  const sphere2 = spheres[j];

                  // è®¡ç®—çƒä½“ä¸­å¿ƒä¹‹é—´çš„è·ç¦»
                  const distance = Math.sqrt(
                      Math.pow(sphere1.center[0] - sphere2.center[0], 2) +
                      Math.pow(sphere1.center[1] - sphere2.center[1], 2) +
                      Math.pow(sphere1.center[2] - sphere2.center[2], 2)
                  );

                  // å¦‚æœè·ç¦»å°äºä¸¤ä¸ªçƒä½“åŠå¾„ä¹‹å’Œçš„1.5å€ï¼Œåˆ™è¿æ¥å®ƒä»¬
                  const maxBondDistance = (sphere1.radius + sphere2.radius) * 1.5;
                  if (distance <= maxBondDistance) {
                      const bondGeometry = new THREE.BufferGeometry().setFromPoints([
                          new THREE.Vector3(sphere1.center[0], sphere1.center[1], sphere1.center[2]),
                          new THREE.Vector3(sphere2.center[0], sphere2.center[1], sphere2.center[2])
                      ]);

                      const bondLine = new THREE.Line(bondGeometry, bondMaterial);
                      bondLine.name = 'bond_' + i + '_' + j;
                      group.add(bondLine);
                  }
              }
          }
      }

      // è®¡ç®—å¤šçƒè´¨å¿ƒ
      function calculateSphereCentroid(spheres) {
          const totalVolume = spheres.reduce((sum, sphere) =>
              sum + (4/3) * Math.PI * Math.pow(sphere.radius, 3), 0);

          let weightedX = 0, weightedY = 0, weightedZ = 0;

          spheres.forEach(sphere => {
              const volume = (4/3) * Math.PI * Math.pow(sphere.radius, 3);
              const weight = volume / totalVolume;

              weightedX += sphere.center[0] * weight;
              weightedY += sphere.center[1] * weight;
              weightedZ += sphere.center[2] * weight;
          });

          return [weightedX, weightedY, weightedZ];
      }

      // åˆ›å»ºç»“æ„å¯è§†åŒ–ï¼ˆæ”¯æŒå¤šçƒæ‹Ÿåˆï¼‰
      function createStructureVisualization(structure) {
          console.log('ğŸ¨ === createStructureVisualization START ===');
          console.log('Structure ID:', structure.id);
          console.log('Structure filename:', structure.filename);
          console.log('Structure number:', structure.number);
          console.log('Has visualInfo:', !!structure.visualInfo);

          if (structure.visualInfo) {
              console.log('VisualInfo type:', structure.visualInfo.type);
              console.log('Has geometry:', !!structure.visualInfo.geometry);
              if (structure.visualInfo.geometry) {
                  console.log('Geometry type:', structure.visualInfo.geometry.type);
                  if (structure.visualInfo.geometry.type === 'multi_sphere') {
                      console.log('ğŸ”® MULTISPHERE GEOMETRY FOUND!');
                      console.log('Number of spheres:', structure.visualInfo.geometry.spheres?.length || 0);
                  }
              }
          }

          try {
              const group = new THREE.Group();
              group.name = structure.id;
              console.log('âœ… Created group for structure:', structure.id);

              // æ£€æŸ¥æ˜¯å¦ä¸ºå•åˆ†å­ç»“æ„ä¸”æœ‰å¤šçƒæ‹Ÿåˆæ•°æ®
              const isMultisphereStructure = structure.number === 1 &&
                  structure.visualInfo &&
                  structure.visualInfo.geometry &&
                  structure.visualInfo.geometry.type === 'multi_sphere';

              console.log('Is multisphere structure:', isMultisphereStructure);

              if (isMultisphereStructure) {
                  console.log('ğŸ”® Creating multisphere representation for single molecule:', structure.id);

                  // åˆ›å»ºå¤šçƒæ‹Ÿåˆå¯è§†åŒ–
                  const multisphereCreated = createMultisphereVisualization(structure, group);

                  if (multisphereCreated) {
                      console.log('âœ… Multisphere representation created successfully');
                  } else {
                      console.warn('âŒ Failed to create multisphere representation, falling back to default');
                  }
              } else {
                  console.log('ğŸ“¦ Not a multisphere structure, using default visualization');
              }

              // å¤„ç†çº¦æŸï¼ˆå¦‚æœæœ‰ï¼‰
              if (structure.constraints && structure.constraints.length > 0) {
                  console.log('Processing', structure.constraints.length, 'constraints for structure:', structure.id);

                  // åŸºäºçº¦æŸåˆ›å»ºå¯è§†åŒ–ï¼Œå¹¶æ·»åŠ åˆ°ç»“æ„ç»„ä¸­
                  structure.constraints.forEach((constraint, index) => {
                      console.log(`Creating constraint ${index}:`, constraint);
                      const constraintMesh = createConstraintVisualization(constraint, structure.id + '_constraint_' + index);
                      if (constraintMesh) {
                          console.log('Successfully created constraint mesh');
                          constraintGroups.set(structure.id + '_constraint_' + index, constraintMesh);
                          group.add(constraintMesh); // æ·»åŠ åˆ°ç»“æ„ç»„è€Œä¸æ˜¯åœºæ™¯
                      } else {
                          console.warn('Failed to create constraint mesh');
                      }
                  });

              } else {
                  console.log('No constraints found, structure will be represented by constraints only');
              }

              // æ·»åŠ åˆ°åœºæ™¯
              structureGroups.set(structure.id, group);
              scene.add(group);

              console.log('Successfully created and added structure group:', structure.id);
              console.log('Current scene children count:', scene.children.length);

          } catch (error) {
              console.error('Error in createStructureVisualization:', error);
          }
      }


      // åˆ›å»ºçº¦æŸå¯è§†åŒ–
      function createConstraintVisualization(constraint, id) {
          console.log('Creating constraint visualization:', constraint, id);
          const geometry = getConstraintGeometry(constraint.geometry, id);
          if (!geometry) {
              console.log('No geometry created for constraint');
              return null;
          }

          // ä» id ä¸­æå–ç»“æ„ ID (æ ¼å¼: structureId_constraint_index)
          const structureId = id.split('_constraint_')[0];
          const structureColor = getStructureColor(structureId);

          // æ ¹æ®çº¦æŸç±»å‹è°ƒæ•´é¢œè‰²
          let constraintColor = structureColor;
          if (constraint.type === 'outside') {
              // outside çº¦æŸä½¿ç”¨ç¨å¾®åçº¢çš„ç»“æ„é¢œè‰²
              const color = new THREE.Color(structureColor);
              color.r = Math.min(1.0, color.r + 0.2);
              constraintColor = color.getHex();
          } else {
              // inside çº¦æŸä½¿ç”¨ç¨å¾®åç»¿çš„ç»“æ„é¢œè‰²
              const color = new THREE.Color(structureColor);
              color.g = Math.min(1.0, color.g + 0.2);
              constraintColor = color.getHex();
          }

          const material = new THREE.MeshLambertMaterial({
              color: constraintColor,
              transparent: true,
              opacity: currentSettings.constraintOpacity,
              wireframe: true
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.name = id;

          // ä¸ºè¡¨é¢çº¦æŸï¼ˆplane å’Œ xygaussï¼‰æ·»åŠ æ–¹å‘ç®­å¤´
          if (constraint.geometry.type === 'plane' || constraint.geometry.type === 'xygauss') {
              const constraintGroup = new THREE.Group();
              constraintGroup.add(mesh);
              
              // åˆ›å»ºæ–¹å‘ç®­å¤´
              const arrows = createSurfaceDirectionArrows(constraint, constraintColor, id);
              arrows.forEach(arrow => constraintGroup.add(arrow));
              
              constraintGroup.name = id;
              console.log('Created constraint group with surface arrows for:', constraint.geometry.type);
              return constraintGroup;
          }

          console.log('Created constraint mesh with color:', constraintColor.toString(16));
          return mesh;
      }

      // è®¡ç®—åœºæ™¯çš„åˆç†å¤§å°ï¼Œç”¨äºç¡®å®šè¡¨é¢çº¦æŸçš„é»˜è®¤å¤§å°
      function calculateSceneSize() {
          if (!currentData || !currentData.input || !currentData.input.structures) {
              return 50; // é»˜è®¤å¤§å°
          }

          let maxSize = 0;
          currentData.input.structures.forEach(structure => {
              if (structure.constraints) {
                  structure.constraints.forEach(constraint => {
                      switch (constraint.geometry.type) {
                          case 'sphere':
                              if (constraint.geometry.parameters.length >= 4) {
                                  const radius = constraint.geometry.parameters[3];
                                  maxSize = Math.max(maxSize, radius * 2);
                              }
                              break;
                          case 'box':
                              if (constraint.geometry.parameters.length >= 6) {
                                  const [x1, y1, z1, x2, y2, z2] = constraint.geometry.parameters;
                                  const size = Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1), Math.abs(z2 - z1));
                                  maxSize = Math.max(maxSize, size);
                              }
                              break;
                          case 'cube':
                              if (constraint.geometry.parameters.length >= 4) {
                                  const size = constraint.geometry.parameters[3];
                                  maxSize = Math.max(maxSize, size);
                              }
                              break;
                          case 'cylinder':
                              if (constraint.geometry.parameters.length >= 7) {
                                  const [x1, y1, z1, x2, y2, z2, radius] = constraint.geometry.parameters;
                                  const height = Math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2);
                                  maxSize = Math.max(maxSize, Math.max(radius * 2, height));
                              }
                              break;
                      }
                  });
              }
          });

          // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å…¶ä»–çº¦æŸï¼Œä½¿ç”¨é»˜è®¤å€¼ï¼Œå¦åˆ™ä½¿ç”¨æ‰¾åˆ°çš„æœ€å¤§å°ºå¯¸çš„1.5å€ä½œä¸ºè¡¨é¢å¤§å°
          return maxSize > 0 ? maxSize * 1.5 : 50;
      }

      // è·å–è¡¨é¢çº¦æŸçš„å¤§å°
      function getSurfaceConstraintSize(constraintId) {
          if (surfaceConstraintSizes.has(constraintId)) {
              return surfaceConstraintSizes.get(constraintId);
          }

          // é¦–æ¬¡è®¿é—®æ—¶ï¼Œè®¾ç½®åŸºäºåœºæ™¯çš„åˆç†é»˜è®¤å€¼
          const defaultSize = calculateSceneSize();
          surfaceConstraintSizes.set(constraintId, defaultSize);
          return defaultSize;
      }

      // è®¾ç½®è¡¨é¢çº¦æŸçš„å¤§å°
      function setSurfaceConstraintSize(constraintId, size) {
          surfaceConstraintSizes.set(constraintId, size);

          // é‡æ–°åˆ›å»ºè¯¥çº¦æŸçš„å‡ ä½•ä½“
          const constraintObject = constraintGroups.get(constraintId);
          if (constraintObject) {
              // è·å–çº¦æŸæ•°æ®
              const parts = constraintId.split('_constraint_');
              const structureId = parts[0];
              const constraintIndex = parseInt(parts[1]);

              const structure = currentData.input.structures.find(s => s.id === structureId);
              if (structure && structure.constraints && structure.constraints[constraintIndex]) {
                  const constraint = structure.constraints[constraintIndex];
                  
                  // åˆ¤æ–­æ˜¯å¦ä¸ºè¡¨é¢çº¦æŸï¼ˆæœ‰ç®­å¤´çš„Groupï¼‰è¿˜æ˜¯æ™®é€šçº¦æŸï¼ˆå•ä¸ªMeshï¼‰
                  if (constraint.geometry.type === 'plane' || constraint.geometry.type === 'xygauss') {
                      // è¡¨é¢çº¦æŸï¼šé‡æ–°åˆ›å»ºæ•´ä¸ªç»„ï¼ˆåŒ…æ‹¬ç®­å¤´ï¼‰
                      const parent = constraintObject.parent;
                      if (parent) {
                          // ç§»é™¤æ—§çš„çº¦æŸç»„
                          parent.remove(constraintObject);
                          
                          // æ¸…ç†æ—§å‡ ä½•ä½“
                          constraintObject.traverse(child => {
                              if (child.geometry) {
                                  child.geometry.dispose();
                              }
                              if (child.material) {
                                  if (child.material.map) {
                                      child.material.map.dispose();
                                  }
                                  child.material.dispose();
                              }
                          });
                          
                          // åˆ›å»ºæ–°çš„çº¦æŸå¯è§†åŒ–ï¼ˆåŒ…æ‹¬æ–°å°ºå¯¸çš„å‡ ä½•ä½“å’Œç®­å¤´ï¼‰
                          const newConstraintVisualization = createConstraintVisualization(constraint, constraintId);
                          if (newConstraintVisualization) {
                              parent.add(newConstraintVisualization);
                              constraintGroups.set(constraintId, newConstraintVisualization);
                          }
                      }
                  } else {
                      // éè¡¨é¢çº¦æŸï¼šåªæ›´æ–°å‡ ä½•ä½“
                      const newGeometry = getConstraintGeometry(constraint.geometry, constraintId);
                      if (newGeometry && constraintObject.geometry) {
                          constraintObject.geometry.dispose(); // æ¸…ç†æ—§å‡ ä½•ä½“
                          constraintObject.geometry = newGeometry;
                      }
                  }
              }
          }
      }

      // è·å–çº¦æŸå‡ ä½•ä½“
      function getConstraintGeometry(geometry, constraintId = null) {
          console.log('Getting constraint geometry:', geometry);
          switch (geometry.type) {
              case 'sphere':
                  if (geometry.parameters.length >= 4) {
                      const [x, y, z, radius] = geometry.parameters;
                      console.log(`Creating sphere at (${x}, ${y}, ${z}) with radius ${radius}`);
                      const sphereGeometry = new THREE.SphereGeometry(radius, currentSettings.geometrySegments, currentSettings.geometrySegments);
                      sphereGeometry.translate(x, y, z);
                      return sphereGeometry;
                  }
                  break;
              case 'box':
                  if (geometry.parameters.length >= 6) {
                      const [x1, y1, z1, x2, y2, z2] = geometry.parameters;
                      const width = Math.abs(x2 - x1);
                      const height = Math.abs(y2 - y1);
                      const depth = Math.abs(z2 - z1);
                      console.log(`Creating box from (${x1}, ${y1}, ${z1}) to (${x2}, ${y2}, ${z2})`);
                      const boxSegments = Math.max(1, Math.floor(currentSettings.geometrySegments / 8));
                      const boxGeometry = new THREE.BoxGeometry(width, height, depth, boxSegments, boxSegments, boxSegments);
                      boxGeometry.translate((x1 + x2) / 2, (y1 + y2) / 2, (z1 + z2) / 2);
                      return boxGeometry;
                  }
                  break;
              case 'cube':
                  // outside cube xmin ymin zmin d
                  if (geometry.parameters.length >= 4) {
                      const [xmin, ymin, zmin, d] = geometry.parameters;
                      console.log(`Creating cube at (${xmin}, ${ymin}, ${zmin}) with size ${d}`);
                      const cubeSegments = Math.max(1, Math.floor(currentSettings.geometrySegments / 8));
                      const cubeGeometry = new THREE.BoxGeometry(d, d, d, cubeSegments, cubeSegments, cubeSegments);
                      cubeGeometry.translate(xmin + d/2, ymin + d/2, zmin + d/2);
                      return cubeGeometry;
                  }
                  break;
              case 'cylinder':
                  if (geometry.parameters.length >= 8) {
                      const [a1, b1, c1, a2, b2, c2, d, l] = geometry.parameters;

                      // a1,b1,c1 æ˜¯èµ·ç‚¹ï¼Œa2,b2,c2 æ˜¯æ–¹å‘å‘é‡ï¼Œd æ˜¯åŠå¾„ï¼Œl æ˜¯é•¿åº¦
                      console.log(`Creating cylinder from (${a1}, ${b1}, ${c1}) direction (${a2}, ${b2}, ${c2}) radius ${d} length ${l}`);

                      // æ ‡å‡†åŒ–æ–¹å‘å‘é‡
                      const dirLength = Math.sqrt(a2*a2 + b2*b2 + c2*c2);
                      if (dirLength === 0) {
                          console.warn('Cylinder direction vector is zero');
                          break;
                      }
                      const dirX = a2 / dirLength;
                      const dirY = b2 / dirLength;
                      const dirZ = c2 / dirLength;

                      // åˆ›å»ºåœ†æŸ±ä½“å‡ ä½•
                      const cylinderGeometry = new THREE.CylinderGeometry(d, d, l, currentSettings.geometrySegments);

                      // Three.js é»˜è®¤åœ†æŸ±ä½“æ²¿ Y è½´ï¼Œéœ€è¦æ—‹è½¬åˆ°æ­£ç¡®æ–¹å‘
                      // è®¡ç®—ä» Y è½´åˆ°ç›®æ ‡æ–¹å‘çš„æ—‹è½¬
                      const yAxis = new THREE.Vector3(0, 1, 0);
                      const targetDir = new THREE.Vector3(dirX, dirY, dirZ);
                      const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, targetDir);
                      cylinderGeometry.applyQuaternion(quaternion);

                      // ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®ï¼ˆåœ†æŸ±ä½“ä¸­å¿ƒï¼‰
                      const centerX = a1 + (dirX * l / 2);
                      const centerY = b1 + (dirY * l / 2);
                      const centerZ = c1 + (dirZ * l / 2);
                      cylinderGeometry.translate(centerX, centerY, centerZ);

                      return cylinderGeometry;
                  }
                  break;
              case 'plane':
                  // above/below plane a b c d (ax + by + cz - d = 0)
                  if (geometry.parameters.length >= 4) {
                      const [a, b, c, d] = geometry.parameters;
                      console.log(`Creating plane with equation ${a}x + ${b}y + ${c}z - ${d} = 0`);

                      // ä½¿ç”¨å¯è°ƒèŠ‚çš„å¹³é¢å¤§å°
                      const planeSize = constraintId ? getSurfaceConstraintSize(constraintId) : 50;
                      const planeSegments = Math.max(4, Math.floor(currentSettings.geometrySegments / 2));
                      const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize, planeSegments, planeSegments);

                      // è®¡ç®—å¹³é¢çš„æ³•å‘é‡
                      const normal = new THREE.Vector3(a, b, c).normalize();

                      // è®¡ç®—å¹³é¢ä¸Šçš„ä¸€ä¸ªç‚¹
                      let point = new THREE.Vector3();
                      if (Math.abs(c) > 0.1) {
                          point.set(0, 0, d / c);
                      } else if (Math.abs(b) > 0.1) {
                          point.set(0, d / b, 0);
                      } else if (Math.abs(a) > 0.1) {
                          point.set(d / a, 0, 0);
                      }

                      // å°†å¹³é¢ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®å¹¶å®šå‘
                      planeGeometry.translate(point.x, point.y, point.z);
                      planeGeometry.lookAt(normal);

                      return planeGeometry;
                  }
                  break;
              case 'ellipsoid':
                  // æ¤­çƒä½“ (ç›®å‰ç”¨çƒä½“è¿‘ä¼¼ï¼Œå¯ä»¥åç»­æ”¹è¿›ä¸ºçœŸæ­£çš„æ¤­çƒä½“)
                  if (geometry.parameters.length >= 7) {
                      const [x, y, z, a, b, c, d] = geometry.parameters;
                      console.log(`Creating ellipsoid at (${x}, ${y}, ${z}) with semi-axes (${a/d}, ${b/d}, ${c/d})`);

                      // åˆ›å»ºå•ä½çƒä½“ç„¶åç¼©æ”¾
                      const ellipsoidGeometry = new THREE.SphereGeometry(1, currentSettings.geometrySegments, currentSettings.geometrySegments);
                      ellipsoidGeometry.scale(a/d, b/d, c/d);
                      ellipsoidGeometry.translate(x, y, z);
                      return ellipsoidGeometry;
                  }
                  break;
              case 'xygauss':
                  // over/below xygauss a1 b1 a2 b2 c h
                  // é«˜æ–¯è¡¨é¢: h * exp(-((x-a1)Â²/(2a2Â²) + (y-b1)Â²/(2b2Â²))) - (z-c) = 0
                  if (geometry.parameters.length >= 6) {
                      const [a1, b1, a2, b2, c, h] = geometry.parameters;
                      console.log(`Creating xygauss surface at (${a1}, ${b1}) with parameters a2=${a2}, b2=${b2}, c=${c}, h=${h}`);

                      // ä½¿ç”¨å¯è°ƒèŠ‚çš„è¡¨é¢èŒƒå›´å¤§å°
                      const surfaceSize = constraintId ? getSurfaceConstraintSize(constraintId) : Math.max(a2, b2) * 3;
                      const resolution = Math.max(8, currentSettings.geometrySegments);
                      const range = surfaceSize / 2;
                      const positions = [];
                      const indices = [];

                      for (let i = 0; i <= resolution; i++) {
                          for (let j = 0; j <= resolution; j++) {
                              const x = a1 + (i / resolution - 0.5) * range * 2;
                              const y = b1 + (j / resolution - 0.5) * range * 2;
                              const z = c + h * Math.exp(-((x - a1) ** 2) / (2 * a2 ** 2) - ((y - b1) ** 2) / (2 * b2 ** 2));

                              positions.push(x, y, z);
                          }
                      }

                      // åˆ›å»ºç´¢å¼•
                      for (let i = 0; i < resolution; i++) {
                          for (let j = 0; j < resolution; j++) {
                              const a = i * (resolution + 1) + j;
                              const b = a + resolution + 1;

                              indices.push(a, b, a + 1);
                              indices.push(b, b + 1, a + 1);
                          }
                      }

                      const gaussGeometry = new THREE.BufferGeometry();
                      gaussGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                      gaussGeometry.setIndex(indices);
                      gaussGeometry.computeVertexNormals();

                      return gaussGeometry;
                  }
                  break;
          }
          console.log('Could not create geometry for:', geometry);
          return null;
      }

      // æ›´æ–°æ§åˆ¶é¢æ¿
      function updateControlPanel() {
          const structureList = document.getElementById('structure-list');
          const constraintList = document.getElementById('constraint-list');

          structureList.innerHTML = '';
          constraintList.innerHTML = '';

          if (!currentData || !currentData.input) return;

          // ç»“æ„åˆ—è¡¨ï¼ˆåŒ…å«çº¦æŸçš„å±‚æ¬¡ç»“æ„ï¼‰
          currentData.input.structures.forEach(structure => {
              // åˆ›å»ºç»“æ„å®¹å™¨
              const structureContainer = document.createElement('div');
              structureContainer.className = 'structure-container';
              structureContainer.style.marginBottom = '10px';
              structureContainer.style.border = '1px solid #444';
              structureContainer.style.borderRadius = '4px';
              structureContainer.style.padding = '8px';

              // åˆ›å»ºç»“æ„ä¸»é¡¹
              const structureItem = document.createElement('div');
              structureItem.className = 'structure-item';
              structureItem.style.fontWeight = 'bold';
              structureItem.style.marginBottom = '5px';

              const structureCheckbox = document.createElement('input');
              structureCheckbox.type = 'checkbox';
              structureCheckbox.className = 'structure-checkbox';
              structureCheckbox.checked = true;
              structureCheckbox.addEventListener('change', () => {
                  toggleStructureVisibility(structure.id, structureCheckbox.checked);
                  // åŒæ—¶åˆ‡æ¢æ‰€æœ‰å­çº¦æŸçš„å¯è§æ€§
                  const constraintCheckboxes = structureContainer.querySelectorAll('.constraint-checkbox');
                  constraintCheckboxes.forEach(cb => {
                      cb.checked = structureCheckbox.checked;
                      const constraintId = cb.getAttribute('data-constraint-id');
                      if (constraintId) {
                          toggleConstraintVisibility(constraintId, structureCheckbox.checked);
                      }
                  });
              });

              const structureInfo = document.createElement('div');
              structureInfo.className = 'structure-info';
              structureInfo.style.display = 'flex';
              structureInfo.style.alignItems = 'center';
              structureInfo.style.flex = '1';

              const structureLabel = document.createElement('span');

              // æ„å»ºç»“æ„æ ‡ç­¾æ–‡æœ¬
              let labelText = 'ğŸ“¦ ' + structure.filename + '<span class="structure-count">(' + structure.number + ')</span>';

              // å¦‚æœæ˜¯å•åˆ†å­ä¸”æœ‰å¤šçƒæ‹Ÿåˆæ•°æ®ï¼Œæ·»åŠ çƒä½“ä¿¡æ¯
              if (structure.number === 1 && structure.visualInfo &&
                  structure.visualInfo.geometry &&
                  structure.visualInfo.geometry.type === 'multi_sphere' &&
                  structure.visualInfo.geometry.spheres) {

                  const sphereCount = structure.visualInfo.geometry.spheres.length;
                  labelText += '<br><span style="font-size: 10px; color: #88c999;">ğŸ”® ' + sphereCount + ' spheres fitted</span>';
              }

              structureLabel.innerHTML = labelText;
              structureLabel.style.flex = '1';

              // æ·»åŠ é¢œè‰²é€‰æ‹©å™¨
              const colorPicker = document.createElement('input');
              colorPicker.type = 'color';
              colorPicker.className = 'structure-color-picker';
              colorPicker.style.width = '20px';
              colorPicker.style.height = '20px';
              colorPicker.style.border = 'none';
              colorPicker.style.borderRadius = '3px';
              colorPicker.style.cursor = 'pointer';
              colorPicker.style.marginLeft = '8px';

              // è®¾ç½®å½“å‰é¢œè‰²
              const currentColor = getStructureColor(structure.id);
              colorPicker.value = '#' + currentColor.toString(16).padStart(6, '0');

              colorPicker.addEventListener('change', (event) => {
                  const newColor = parseInt(event.target.value.slice(1), 16);
                  setStructureColor(structure.id, newColor);
              });

              structureInfo.appendChild(structureLabel);
              structureInfo.appendChild(colorPicker);

              structureItem.appendChild(structureCheckbox);
              structureItem.appendChild(structureInfo);
              structureContainer.appendChild(structureItem);

              // æ·»åŠ å¤šçƒæ‹Ÿåˆä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
              if (structure.number === 1 && structure.visualInfo &&
                  structure.visualInfo.geometry &&
                  structure.visualInfo.geometry.type === 'multi_sphere' &&
                  structure.visualInfo.geometry.spheres) {

                  const multisphereInfo = document.createElement('div');
                  multisphereInfo.style.marginLeft = '20px';
                  multisphereInfo.style.borderLeft = '2px solid #88c999';
                  multisphereInfo.style.paddingLeft = '8px';
                  multisphereInfo.style.marginTop = '5px';
                  multisphereInfo.style.marginBottom = '5px';

                  const spheres = structure.visualInfo.geometry.spheres;

                  // å¤šçƒæ‹Ÿåˆæ€»è§ˆ
                  const multisphereHeader = document.createElement('div');
                  multisphereHeader.style.fontSize = '11px';
                  multisphereHeader.style.color = '#88c999';
                  multisphereHeader.style.fontWeight = 'bold';
                  multisphereHeader.style.marginBottom = '3px';
                  multisphereHeader.textContent = 'ğŸ”® Multi-sphere Fitting (' + spheres.length + ' spheres)';
                  multisphereInfo.appendChild(multisphereHeader);

                  // è®¡ç®—æ€»ä½“ç§¯
                  const totalVolume = spheres.reduce((sum, sphere) =>
                      sum + (4/3) * Math.PI * Math.pow(sphere.radius, 3), 0);

                  // å¹³å‡åŠå¾„
                  const avgRadius = spheres.reduce((sum, sphere) => sum + sphere.radius, 0) / spheres.length;

                  // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                  const statsDiv = document.createElement('div');
                  statsDiv.style.fontSize = '10px';
                  statsDiv.style.color = '#aaa';
                  statsDiv.style.marginBottom = '3px';
                  statsDiv.textContent = 'Volume: ' + totalVolume.toFixed(1) + ' Ã…Â³, Avg radius: ' + avgRadius.toFixed(1) + ' Ã…';
                  multisphereInfo.appendChild(statsDiv);

                  // æ˜¾ç¤ºæ¯ä¸ªçƒä½“ï¼ˆæœ€å¤šæ˜¾ç¤ºå‰5ä¸ªï¼‰
                  const maxDisplaySpheres = Math.min(5, spheres.length);
                  for (let i = 0; i < maxDisplaySpheres; i++) {
                      const sphere = spheres[i];
                      const sphereItem = document.createElement('div');
                      sphereItem.style.fontSize = '9px';
                      sphereItem.style.color = '#999';
                      sphereItem.style.marginLeft = '10px';
                      sphereItem.style.marginBottom = '1px';

                      const centerStr = sphere.center.map(c => c.toFixed(1)).join(', ');
                      sphereItem.textContent = 'â€¢ Sphere ' + (i + 1) + ': (' + centerStr + ') r=' + sphere.radius.toFixed(1);
                      multisphereInfo.appendChild(sphereItem);
                  }

                  // å¦‚æœæœ‰æ›´å¤šçƒä½“ï¼Œæ˜¾ç¤ºçœç•¥ä¿¡æ¯
                  if (spheres.length > maxDisplaySpheres) {
                      const moreInfo = document.createElement('div');
                      moreInfo.style.fontSize = '9px';
                      moreInfo.style.color = '#777';
                      moreInfo.style.marginLeft = '10px';
                      moreInfo.style.fontStyle = 'italic';
                      moreInfo.textContent = '... and ' + (spheres.length - maxDisplaySpheres) + ' more spheres';
                      multisphereInfo.appendChild(moreInfo);
                  }

                  structureContainer.appendChild(multisphereInfo);
              }

              // æ·»åŠ çº¦æŸå­é¡¹
              if (structure.constraints && structure.constraints.length > 0) {
                  const constraintsSublist = document.createElement('div');
                  constraintsSublist.style.marginLeft = '20px';
                  constraintsSublist.style.borderLeft = '2px solid #666';
                  constraintsSublist.style.paddingLeft = '8px';

                  structure.constraints.forEach((constraint, index) => {
                      const constraintItem = document.createElement('div');
                      constraintItem.className = 'structure-item constraint-item';
                      constraintItem.style.fontSize = '11px';
                      constraintItem.style.color = '#bbb';
                      constraintItem.style.marginBottom = '3px';

                      const constraintCheckbox = document.createElement('input');
                      constraintCheckbox.type = 'checkbox';
                      constraintCheckbox.className = 'structure-checkbox constraint-checkbox';
                      constraintCheckbox.checked = true;
                      const constraintId = structure.id + '_constraint_' + index;
                      constraintCheckbox.setAttribute('data-constraint-id', constraintId);
                      constraintCheckbox.addEventListener('change', () => {
                          toggleConstraintVisibility(constraintId, constraintCheckbox.checked);
                          // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰çº¦æŸéƒ½è¢«å–æ¶ˆé€‰ä¸­ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å–æ¶ˆé€‰ä¸­ç»“æ„
                          const allConstraintCheckboxes = constraintsSublist.querySelectorAll('.constraint-checkbox');
                          const anyChecked = Array.from(allConstraintCheckboxes).some(cb => cb.checked);
                          structureCheckbox.checked = anyChecked;
                          toggleStructureVisibility(structure.id, anyChecked);
                      });

                      const constraintInfo = document.createElement('div');
                      constraintInfo.className = 'structure-info';

                      // æ›´è¯¦ç»†çš„çº¦æŸä¿¡æ¯
                      let constraintText = `ğŸ”§ ${constraint.type} ${constraint.geometry.type}`;
                      if (constraint.geometry.parameters) {
                          switch (constraint.geometry.type) {
                              case 'sphere':
                                  if (constraint.geometry.parameters.length >= 4) {
                                      const [x, y, z, r] = constraint.geometry.parameters;
                                      constraintText += ` (r=${r.toFixed(1)})`;
                                  }
                                  break;
                              case 'box':
                                  if (constraint.geometry.parameters.length >= 6) {
                                      const [x1, y1, z1, x2, y2, z2] = constraint.geometry.parameters;
                                      const w = Math.abs(x2 - x1);
                                      const h = Math.abs(y2 - y1);
                                      const d = Math.abs(z2 - z1);
                                      constraintText += ` (${w.toFixed(1)}Ã—${h.toFixed(1)}Ã—${d.toFixed(1)})`;
                                  }
                                  break;
                              case 'cube':
                                  if (constraint.geometry.parameters.length >= 4) {
                                      const d = constraint.geometry.parameters[3];
                                      constraintText += ` (size=${d.toFixed(1)})`;
                                  }
                                  break;
                              case 'cylinder':
                                  if (constraint.geometry.parameters.length >= 7) {
                                      const r = constraint.geometry.parameters[6];
                                      constraintText += ` (r=${r.toFixed(1)})`;
                                  }
                                  break;
                              case 'plane':
                                  if (constraint.geometry.parameters.length >= 4) {
                                      const [a, b, c, d] = constraint.geometry.parameters;
                                      constraintText += ` (${a.toFixed(1)}x+${b.toFixed(1)}y+${c.toFixed(1)}z=${d.toFixed(1)})`;
                                  }
                                  break;
                              case 'ellipsoid':
                                  if (constraint.geometry.parameters.length >= 6) {
                                      const [x, y, z, a, b, c] = constraint.geometry.parameters;
                                      constraintText += ` (a=${a.toFixed(1)}, b=${b.toFixed(1)}, c=${c.toFixed(1)})`;
                                  }
                                  break;
                              case 'xygauss':
                                  if (constraint.geometry.parameters.length >= 6) {
                                      const [a1, b1, a2, b2, c, h] = constraint.geometry.parameters;
                                      constraintText += ` (Ïƒx=${a2.toFixed(1)}, Ïƒy=${b2.toFixed(1)}, h=${h.toFixed(1)})`;
                                  }
                                  break;
                          }
                      }
                      constraintInfo.textContent = constraintText;

                      constraintItem.appendChild(constraintCheckbox);
                      constraintItem.appendChild(constraintInfo);

                      constraintsSublist.appendChild(constraintItem);

                      // ä¸ºè¡¨é¢çº¦æŸæ·»åŠ å¤§å°æ»‘å—ï¼ˆæ”¾åœ¨çº¦æŸé¡¹ä¸‹æ–¹ï¼‰
                      if (constraint.geometry.type === 'plane' || constraint.geometry.type === 'xygauss') {
                          const sliderContainer = document.createElement('div');
                          sliderContainer.className = 'surface-slider-container';
                          sliderContainer.style.marginLeft = '25px'; // ä¸çº¦æŸé¡¹å¯¹é½
                          sliderContainer.style.marginTop = '3px';
                          sliderContainer.style.marginBottom = '5px';

                          const sliderLabel = document.createElement('span');
                          sliderLabel.textContent = 'Size:';
                          sliderLabel.style.fontSize = '10px';
                          sliderLabel.style.color = '#999';
                          sliderLabel.style.minWidth = '30px';
                          sliderLabel.style.display = 'inline-block';

                          const slider = document.createElement('input');
                          slider.type = 'range';
                          slider.className = 'surface-slider';
                          slider.min = '10';
                          slider.max = '200';
                          slider.step = '2';
                          slider.style.margin = '0 5px';
                          slider.style.width = '105px'; // é™åˆ¶æ»‘å—å®½åº¦

                          // è·å–å½“å‰å¤§å°
                          const currentSize = getSurfaceConstraintSize(constraintId);
                          slider.value = currentSize.toString();

                          const valueDisplay = document.createElement('span');
                          valueDisplay.style.fontSize = '10px';
                          valueDisplay.style.color = '#999';
                          valueDisplay.style.minWidth = '25px';
                          valueDisplay.style.display = 'inline-block';
                          valueDisplay.textContent = currentSize.toFixed(0);

                          // æ»‘å—å˜åŒ–äº‹ä»¶
                          slider.addEventListener('input', () => {
                              const newSize = parseFloat(slider.value);
                              valueDisplay.textContent = newSize.toFixed(0);
                              setSurfaceConstraintSize(constraintId, newSize);
                          });

                          sliderContainer.appendChild(sliderLabel);
                          sliderContainer.appendChild(slider);
                          sliderContainer.appendChild(valueDisplay);
                          constraintsSublist.appendChild(sliderContainer);
                      }
                  });

                  structureContainer.appendChild(constraintsSublist);
              }

              structureList.appendChild(structureContainer);
          });

          // åœ¨çº¦æŸåŒºåŸŸæ˜¾ç¤ºå…¨å±€ç»Ÿè®¡ä¿¡æ¯
          const statsDiv = document.createElement('div');
          statsDiv.style.fontSize = '11px';
          statsDiv.style.color = '#888';
          statsDiv.style.padding = '5px';
          statsDiv.style.borderTop = '1px solid #444';

          const totalStructures = currentData.input.structures.length;
          const totalConstraints = currentData.input.structures.reduce((sum, s) => sum + (s.constraints?.length || 0), 0);
          statsDiv.textContent = `Total: ${totalStructures} structures, ${totalConstraints} constraints`;

          constraintList.appendChild(statsDiv);
      }

      // åˆ‡æ¢ç»“æ„å¯è§æ€§
      function toggleStructureVisibility(structureId, visible) {
          const group = structureGroups.get(structureId);
          if (group) {
              group.visible = visible;
          }
      }

      // åˆ‡æ¢çº¦æŸå¯è§æ€§
      function toggleConstraintVisibility(constraintId, visible) {
          const constraintMesh = constraintGroups.get(constraintId);
          if (constraintMesh) {
              constraintMesh.visible = visible;
          }
      }

      // é‡ç½®ç›¸æœº
      function resetCamera() {
          camera.position.set(50, 50, 50);
          camera.lookAt(0, 0, 0);
          fitCameraToScene();
      }

      // åˆ‡æ¢çº¿æ¡†æ¨¡å¼
      function toggleWireframe() {
          wireframeMode = !wireframeMode;
          structureGroups.forEach(group => {
              group.traverse(child => {
                  if (child.material) {
                      child.material.wireframe = wireframeMode;
                  }
              });
          });
          constraintGroups.forEach(group => {
              if (group.material) {
                  group.material.wireframe = wireframeMode;
              }
          });
      }

      // éšæœºåŒ–é¢œè‰²
      function randomizeColors() {
          if (!currentData || !currentData.input || !currentData.input.structures) return;

          currentData.input.structures.forEach(structure => {
              // ç”Ÿæˆéšæœºé¢œè‰²
              const randomColor = Math.floor(Math.random() * 16777215); // 0xFFFFFF
              setStructureColor(structure.id, randomColor);
          });

          // æ›´æ–°æ§åˆ¶é¢æ¿ä¸­çš„é¢œè‰²é€‰æ‹©å™¨
          updateControlPanel();
      }

      // é‡ç½®é¢œè‰²
      function resetColors() {
          if (!window.structureColorMap) return;

          // æ¸…é™¤é¢œè‰²æ˜ å°„
          window.structureColorMap.clear();
          window.structureColorIndex = 0;

          if (!currentData || !currentData.input || !currentData.input.structures) return;

          // é‡æ–°åˆ†é…é»˜è®¤é¢œè‰²
          currentData.input.structures.forEach(structure => {
              const defaultColor = getStructureColor(structure.id);
              updateStructureColors(structure.id, defaultColor);
          });

          // æ›´æ–°æ§åˆ¶é¢æ¿ä¸­çš„é¢œè‰²é€‰æ‹©å™¨
          updateControlPanel();
      }

      // è°ƒæ•´ç›¸æœºé€‚åº”åœºæ™¯
      function fitCameraToScene() {
          const box = new THREE.Box3();
          scene.traverse(object => {
              if (object.geometry) {
                  box.expandByObject(object);
              }
          });

          if (!box.isEmpty()) {
              const center = box.getCenter(new THREE.Vector3());
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const distance = maxDim * 2;

              camera.position.set(center.x + distance, center.y + distance, center.z + distance);
              camera.lookAt(center);
          }
      }

      // è·å–ç»“æ„é¢œè‰²
      function getStructureColor(structureId) {
          const colors = [
              0xff6b6b,  // çº¢è‰²
              0x4ecdc4,  // é’è‰²
              0x45b7d1,  // è“è‰²
              0x96ceb4,  // ç»¿è‰²
              0xffeaa7,  // é»„è‰²
              0xdda0dd,  // ç´«è‰²
              0x74b9ff,  // äº®è“è‰²
              0xfd79a8,  // ç²‰è‰²
              0xa29bfe,  // æ·¡ç´«è‰²
              0x6c5ce7   // æ·±ç´«è‰²
          ];

          // ä¸ºæ¯ä¸ªç»“æ„åˆ†é…ä¸€ä¸ªå›ºå®šçš„é¢œè‰²ç´¢å¼•
          if (!window.structureColorMap) {
              window.structureColorMap = new Map();
              window.structureColorIndex = 0;
          }

          if (!window.structureColorMap.has(structureId)) {
              window.structureColorMap.set(structureId, colors[window.structureColorIndex % colors.length]);
              window.structureColorIndex++;
          }

          return window.structureColorMap.get(structureId);
      }

      // è®¾ç½®ç»“æ„é¢œè‰²
      function setStructureColor(structureId, color) {
          if (!window.structureColorMap) {
              window.structureColorMap = new Map();
          }
          window.structureColorMap.set(structureId, color);

          // æ›´æ–°ç°æœ‰çš„ç»“æ„é¢œè‰²
          updateStructureColors(structureId, color);
      }

      // æ›´æ–°ç»“æ„é¢œè‰²
      function updateStructureColors(structureId, color) {
          const group = structureGroups.get(structureId);
          if (group) {
              group.traverse(child => {
                  if (child.material && (child.name === structureId || child.name.includes(structureId))) {
                      child.material.color.setHex(color);
                  }
              });
          }

          // æ›´æ–°çº¦æŸé¢œè‰²
          constraintGroups.forEach((constraintGroup, constraintId) => {
              if (constraintId.startsWith(structureId)) {
                  if (constraintGroup.material) {
                      // çº¦æŸä½¿ç”¨ç¨å¾®é€æ˜çš„ç»“æ„é¢œè‰²
                      const constraintColor = new THREE.Color(color);
                      constraintColor.multiplyScalar(0.7); // ç¨å¾®æš—ä¸€äº›
                      constraintGroup.material.color = constraintColor;
                  }
              }
          });
      }

      // ========== è¡¨é¢çº¦æŸç®­å¤´åŠŸèƒ½ ==========

      // å­˜å‚¨å½“å‰å¤„ç†çš„çº¦æŸä¿¡æ¯
      let currentConstraintInfo = null;

      // ä¸ºè¡¨é¢çº¦æŸåˆ›å»ºæ–¹å‘ç®­å¤´
      function createSurfaceDirectionArrows(constraint, color, constraintId) {
          currentConstraintInfo = constraint; // è®¾ç½®å½“å‰çº¦æŸä¿¡æ¯
          const arrows = [];
          const arrowColor = new THREE.Color(color);
          arrowColor.multiplyScalar(1.2); // ç¨å¾®äº®ä¸€äº›ä»¥ä¾¿åŒºåˆ†
          
          if (constraint.geometry.type === 'plane') {
              arrows.push(...createPlaneDirectionArrows(constraint, arrowColor, constraintId));
          } else if (constraint.geometry.type === 'xygauss') {
              arrows.push(...createXYGaussDirectionArrows(constraint, arrowColor, constraintId));
          }
          
          currentConstraintInfo = null; // æ¸…é™¤çº¦æŸä¿¡æ¯
          return arrows;
      }

      // ä¸ºå¹³é¢çº¦æŸåˆ›å»ºæ–¹å‘ç®­å¤´
      function createPlaneDirectionArrows(constraint, color, constraintId) {
          const arrows = [];
          const [a, b, c, d] = constraint.geometry.parameters;
          
          // è®¡ç®—å¹³é¢æ³•å‘é‡
          const normal = new THREE.Vector3(a, b, c).normalize();
          
          // è®¡ç®—å¹³é¢ä¸Šçš„å‚è€ƒç‚¹
          let planePoint = new THREE.Vector3();
          if (Math.abs(c) > 0.1) {
              planePoint.set(0, 0, d / c);
          } else if (Math.abs(b) > 0.1) {
              planePoint.set(0, d / b, 0);
          } else if (Math.abs(a) > 0.1) {
              planePoint.set(d / a, 0, 0);
          }
          
          // æ ¹æ®çº¦æŸç±»å‹ç¡®å®šç®­å¤´æ–¹å‘
          let arrowDirection = normal.clone();
          if (constraint.type === 'below') {
              arrowDirection.negate(); // below æ—¶æ–¹å‘ç›¸å
          }
          
          // è·å–å½“å‰è¡¨é¢å¤§å°å¹¶è°ƒæ•´ç®­å¤´é—´è·
          const surfaceSize = constraintId ? getSurfaceConstraintSize(constraintId) : 50;
          const arrowSpacing = Math.min(surfaceSize * 0.2, 15); // æ ¹æ®è¡¨é¢å¤§å°è°ƒæ•´ç®­å¤´é—´è·
          
          // åˆ›å»ºå¤šä¸ªç®­å¤´æ˜¾ç¤ºåœ¨å¹³é¢ä¸Šä¸åŒä½ç½®
          const arrowPositions = [
              planePoint.clone(),
              planePoint.clone().add(new THREE.Vector3(arrowSpacing, 0, 0)),
              planePoint.clone().add(new THREE.Vector3(-arrowSpacing, 0, 0)),
              planePoint.clone().add(new THREE.Vector3(0, arrowSpacing, 0)),
              planePoint.clone().add(new THREE.Vector3(0, -arrowSpacing, 0)),
              planePoint.clone().add(new THREE.Vector3(arrowSpacing * 0.7, arrowSpacing * 0.7, 0)),
              planePoint.clone().add(new THREE.Vector3(-arrowSpacing * 0.7, -arrowSpacing * 0.7, 0))
          ];
          
          arrowPositions.forEach((position, index) => {
              const arrow = createArrow(position, arrowDirection, 8, color, constraint.type);
              arrow.name = `plane_arrow_${index}`;
              arrows.push(arrow);
          });
          
          console.log(`Created ${arrows.length} plane arrows for ${constraint.type} constraint`);
          return arrows;
      }

      // ä¸º XY é«˜æ–¯è¡¨é¢çº¦æŸåˆ›å»ºæ–¹å‘ç®­å¤´
      function createXYGaussDirectionArrows(constraint, color, constraintId) {
          const arrows = [];
          const [a1, b1, a2, b2, c, h] = constraint.geometry.parameters;
          
          // é«˜æ–¯è¡¨é¢çš„ä¸­å¿ƒç‚¹
          const centerPoint = new THREE.Vector3(a1, b1, c);
          
          // æ ¹æ®çº¦æŸç±»å‹ç¡®å®šç®­å¤´æ–¹å‘ï¼ˆé«˜æ–¯è¡¨é¢å§‹ç»ˆåœ¨ XY å¹³é¢ï¼Œæ–¹å‘ä¸º Z è½´ï¼‰
          let arrowDirection = new THREE.Vector3(0, 0, 1);
          if (constraint.type === 'below') {
              arrowDirection.negate(); // below æ—¶æŒ‡å‘ -Z æ–¹å‘
          }
          
          // è·å–å½“å‰è¡¨é¢å¤§å°å¹¶è°ƒæ•´ç®­å¤´åˆ†å¸ƒ
          const surfaceSize = constraintId ? getSurfaceConstraintSize(constraintId) : Math.max(a2, b2) * 3;
          const scaleFactor = Math.min(surfaceSize / (Math.max(a2, b2) * 3), 2.0); // é™åˆ¶æœ€å¤§ç¼©æ”¾å€æ•°
          
          // åœ¨é«˜æ–¯è¡¨é¢çš„å‡ ä¸ªç‰¹å¾ç‚¹åˆ›å»ºç®­å¤´
          const arrowPositions = [
              centerPoint.clone(), // ä¸­å¿ƒ
              centerPoint.clone().add(new THREE.Vector3(a2 * 0.8 * scaleFactor, 0, 0)), // X æ–¹å‘åç§»
              centerPoint.clone().add(new THREE.Vector3(-a2 * 0.8 * scaleFactor, 0, 0)),
              centerPoint.clone().add(new THREE.Vector3(0, b2 * 0.8 * scaleFactor, 0)), // Y æ–¹å‘åç§»
              centerPoint.clone().add(new THREE.Vector3(0, -b2 * 0.8 * scaleFactor, 0)),
              centerPoint.clone().add(new THREE.Vector3(a2 * 0.6 * scaleFactor, b2 * 0.6 * scaleFactor, 0)), // å¯¹è§’ä½ç½®
              centerPoint.clone().add(new THREE.Vector3(-a2 * 0.6 * scaleFactor, -b2 * 0.6 * scaleFactor, 0))
          ];
          
          arrowPositions.forEach((position, index) => {
              // è®¡ç®—è¯¥ä½ç½®çš„é«˜æ–¯è¡¨é¢é«˜åº¦
              const gaussHeight = h * Math.exp(-((position.x - a1) ** 2) / (2 * a2 ** 2) - ((position.y - b1) ** 2) / (2 * b2 ** 2));
              position.z = c + gaussHeight;
              
              const arrow = createArrow(position, arrowDirection, 6, color, constraint.type);
              arrow.name = `xygauss_arrow_${index}`;
              arrows.push(arrow);
          });
          
          console.log(`Created ${arrows.length} xygauss arrows for ${constraint.type} constraint`);
          return arrows;
      }

      // åˆ›å»ºç®­å¤´å‡ ä½•ä½“
      function createArrow(position, direction, length, color, constraintType) {
          const arrowGroup = new THREE.Group();
          
          // æ ‡å‡†åŒ–æ–¹å‘å‘é‡
          const normalizedDirection = direction.clone().normalize();
          
          // åˆ›å»ºç®­å¤´ä¸»ä½“ï¼ˆåœ†æŸ±ä½“ï¼‰
          const shaftLength = length * 0.7;
          const shaftRadius = length * 0.025;
          const shaftGeometry = new THREE.CylinderGeometry(shaftRadius, shaftRadius, shaftLength, 8);
          const shaftMaterial = new THREE.MeshLambertMaterial({ 
              color: color,
              transparent: true,
              opacity: 0.8
          });
          const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
          
          // åˆ›å»ºç®­å¤´å¤´éƒ¨ï¼ˆåœ†é”¥ä½“ï¼‰
          const headLength = length * 0.3;
          const headRadius = length * 0.08;
          const headGeometry = new THREE.ConeGeometry(headRadius, headLength, 8);
          const headMaterial = new THREE.MeshLambertMaterial({ 
              color: color,
              transparent: true,
              opacity: 0.9
          });
          const head = new THREE.Mesh(headGeometry, headMaterial);
          
          // å®šä½ç®­å¤´ç»„ä»¶
          shaft.position.set(0, shaftLength / 2, 0);
          head.position.set(0, shaftLength + headLength / 2, 0);
          
          arrowGroup.add(shaft);
          arrowGroup.add(head);
          
          // æ—‹è½¬ç®­å¤´ä½¿å…¶æŒ‡å‘æ­£ç¡®æ–¹å‘
          const yAxis = new THREE.Vector3(0, 1, 0);
          const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, normalizedDirection);
          arrowGroup.applyQuaternion(quaternion);
          
          // è®¾ç½®ç®­å¤´ä½ç½®
          arrowGroup.position.copy(position);
          
          // æ·»åŠ çº¦æŸç±»å‹æ ‡ç­¾ï¼ˆå°çš„æ–‡å­—æç¤ºï¼‰
          if (constraintType) {
              const textSprite = createTextSprite(constraintType.toUpperCase(), color);
              textSprite.position.set(0, length + 2, 0);
              arrowGroup.add(textSprite);
          }
          
          return arrowGroup;
      }

      // åˆ›å»ºæ–‡å­—ç²¾çµï¼ˆç”¨äºæ˜¾ç¤ºçº¦æŸç±»å‹ï¼‰
      function createTextSprite(text, color) {
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = 128;
          canvas.height = 64;
          
          // è®¾ç½®ç”»å¸ƒèƒŒæ™¯ä¸ºåŠé€æ˜é»‘è‰²
          context.fillStyle = 'rgba(0, 0, 0, 0.7)';
          context.fillRect(0, 0, canvas.width, canvas.height);
          
          // ç»˜åˆ¶æ–‡å­—
          context.font = 'bold 20px Arial';
          context.fillStyle = `#${color.getHexString()}`;
          context.strokeStyle = '#000000';
          context.lineWidth = 2;
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          
          // å…ˆæè¾¹å†å¡«å……ï¼Œäº§ç”Ÿè¾¹æ¡†æ•ˆæœ
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillText(text, canvas.width / 2, canvas.height / 2);
          
          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({ 
              map: texture,
              transparent: true,
              opacity: 0.9
          });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(3, 1.5, 1); // ç¨å¾®è°ƒæ•´å¤§å°ä½¿å…¶æ›´æ¸…æ™°
          
          return sprite;
      }

      // æ¶ˆæ¯å¤„ç†
      window.addEventListener('message', event => {
          console.log('=== WEBVIEW MESSAGE RECEIVED ===');
          console.log('Message data:', event.data);
          console.log('Three.js ready status:', isThreeJSReady);

          const message = event.data;

          // æ·»åŠ è§†è§‰ç¡®è®¤
          if (message.type === 'update') {
              console.log('ğŸ“¦ UPDATE message received! Creating alert...');
              // alert('æ”¶åˆ° UPDATE æ¶ˆæ¯ï¼æ­£åœ¨å¤„ç†...');
          }

          if (!isThreeJSReady && message.type !== 'ready') {
              console.log('âš ï¸ Three.js not ready, ignoring message:', message);
              // alert('Three.js è¿˜æœªå‡†å¤‡å¥½ï¼Œå¿½ç•¥æ¶ˆæ¯: ' + message.type);
              return;
          }

          switch (message.type) {
              case 'update':
                  console.log('ğŸ¯ Processing update message');
                  try {
                      updateData(message);
                      console.log('âœ… Update processing completed');
                  } catch (error) {
                      console.error('âŒ Error in updateData:', error);
                      // alert('æ›´æ–°æ•°æ®æ—¶å‡ºé”™: ' + error.message);
                  }
                  break;
              case 'toggleStructure':
                  console.log('ğŸ”„ Processing toggleStructure message');
                  toggleStructureVisibility(message.structureId, message.visible);
                  break;
              case 'resetCamera':
                  console.log('ğŸ“· Processing resetCamera message');
                  resetCamera();
                  break;
              default:
                  console.log('â“ Unknown message type:', message.type);
          }

          console.log('=== MESSAGE PROCESSING COMPLETE ===');
      });

      // åˆ‡æ¢å¤šçƒæ˜¾ç¤º
      let multisphereVisible = true;
      function toggleMultisphere() {
          multisphereVisible = !multisphereVisible;

          structureGroups.forEach(group => {
              group.traverse(child => {
                  // åˆ‡æ¢å¤šçƒå’Œç›¸å…³å…ƒç´ çš„å¯è§æ€§
                  if (child.name && (
                      child.name.includes('_multisphere_') ||
                      child.name.includes('_centroid') ||
                      child.name.includes('bond_')
                  )) {
                      child.visible = multisphereVisible;
                  }
              });
          });

          console.log('Multisphere visibility toggled to:', multisphereVisible);
      }

      // åˆ‡æ¢è¡¨é¢ç®­å¤´æ˜¾ç¤º
      let surfaceArrowsVisible = true;
      function toggleSurfaceArrows() {
          surfaceArrowsVisible = !surfaceArrowsVisible;

          // éå†æ‰€æœ‰çº¦æŸç»„ï¼Œåˆ‡æ¢ç®­å¤´çš„å¯è§æ€§
          constraintGroups.forEach(constraintGroup => {
              if (constraintGroup.children) {
                  constraintGroup.traverse(child => {
                      // åˆ‡æ¢ç®­å¤´å’Œç›¸å…³å…ƒç´ çš„å¯è§æ€§
                      if (child.name && (
                          child.name.includes('plane_arrow_') ||
                          child.name.includes('xygauss_arrow_')
                      )) {
                          child.visible = surfaceArrowsVisible;
                      }
                  });
              }
          });

          // åŒæ—¶éå†ç»“æ„ç»„ä¸­çš„çº¦æŸï¼ˆå› ä¸ºçº¦æŸå¯èƒ½ä½œä¸ºç»“æ„çš„å­å¯¹è±¡å­˜åœ¨ï¼‰
          structureGroups.forEach(group => {
              group.traverse(child => {
                  if (child.name && (
                      child.name.includes('plane_arrow_') ||
                      child.name.includes('xygauss_arrow_')
                  )) {
                      child.visible = surfaceArrowsVisible;
                  }
              });
          });

          console.log('Surface arrows visibility toggled to:', surfaceArrowsVisible);
      }

      // ========== è®¾ç½®åŠŸèƒ½ ==========

      /**
       * ä»æ‰©å±•ç«¯åº”ç”¨é…ç½®
       */
      function applySettingsFromExtension(settings) {
          console.log('ğŸ“ Applying settings from extension:', settings);
          
          // æ›´æ–°å½“å‰è®¾ç½®
          currentSettings = { ...currentSettings, ...settings };
          
          // æ›´æ–°UIæ˜¾ç¤º
          updateSettingsUI();
          
          // åº”ç”¨è®¾ç½®åˆ°åœºæ™¯
          applyAllSettings();
          
          console.log('âœ… Settings applied from extension');
      }

      /**
       * å‘é€è®¾ç½®æ›´æ–°åˆ°æ‰©å±•ç«¯
       */
      function sendSettingsToExtension(settings) {
          if (vscode) {
              try {
                  vscode.postMessage({
                      type: 'updateSettings',
                      settings: settings
                  });
                  console.log('ğŸ“¤ Settings sent to extension:', settings);
              } catch (error) {
                  console.error('âŒ Failed to send settings to extension:', error);
              }
          }
      }

      // åˆå§‹åŒ–è®¾ç½®ç•Œé¢
      function initializeSettings() {
          console.log('ğŸ›ï¸ Initializing settings interface...');
          
          // ç”Ÿæˆä¸»é¢˜é€‰é¡¹
          generateThemeOptions();
          
          // ç”ŸæˆèƒŒæ™¯è‰²é¢„è®¾
          generateBackgroundPresets();
          
          // æ›´æ–°UIæ˜¾ç¤ºå€¼
          updateSettingsUI();
          
          console.log('âœ… Settings interface initialized');
      }

      // ç”Ÿæˆä¸»é¢˜é€‰é¡¹
      function generateThemeOptions() {
          const themeGrid = document.getElementById('theme-grid');
          themeGrid.innerHTML = '';
          
          Object.keys(colorThemes).forEach(themeKey => {
              const theme = colorThemes[themeKey];
              const themeDiv = document.createElement('div');
              themeDiv.className = 'theme-option';
              themeDiv.onclick = () => selectTheme(themeKey);
              
              if (themeKey === currentSettings.colorTheme) {
                  themeDiv.classList.add('active');
              }
              
              themeDiv.innerHTML = `
                  <div>${theme.name}</div>
                  <div class="theme-colors">
                      ${theme.colors.slice(0, 3).map(color => 
                          `<div class="theme-color" style="background-color: #${color.toString(16).padStart(6, '0')};"></div>`
                      ).join('')}
                  </div>
              `;
              
              themeGrid.appendChild(themeDiv);
          });
      }

      // ç”ŸæˆèƒŒæ™¯è‰²é¢„è®¾
      function generateBackgroundPresets() {
          const presetsGrid = document.getElementById('background-presets');
          presetsGrid.innerHTML = '';
          
          backgroundPresets.forEach(preset => {
              const presetDiv = document.createElement('div');
              presetDiv.className = 'color-preset';
              presetDiv.style.backgroundColor = preset.color;
              presetDiv.title = preset.name;
              presetDiv.onclick = () => {
                  document.getElementById('background-color').value = preset.color;
                  updateBackgroundColor(preset.color);
              };
              
              if (preset.color === currentSettings.backgroundColor) {
                  presetDiv.classList.add('active');
              }
              
              presetsGrid.appendChild(presetDiv);
          });
      }

      // åˆ‡æ¢è®¾ç½®é¢æ¿
      function toggleSettings() {
          const panel = document.getElementById('settings-panel');
          panel.classList.toggle('visible');
      }

      // é€‰æ‹©ä¸»é¢˜
      function selectTheme(themeKey) {
          currentSettings.colorTheme = themeKey;
          
          // å‘é€åˆ°æ‰©å±•ç«¯ä¿å­˜
          sendSettingsToExtension({ colorTheme: themeKey });
          
          // æ›´æ–°ä¸»é¢˜é€‰é¡¹çš„æ´»åŠ¨çŠ¶æ€
          document.querySelectorAll('.theme-option').forEach(option => {
              option.classList.remove('active');
          });
          event.target.classList.add('active');
          
          // åº”ç”¨æ–°ä¸»é¢˜
          applyColorTheme();
          
          console.log('Applied color theme:', themeKey);
      }

      // åº”ç”¨é¢œè‰²ä¸»é¢˜
      function applyColorTheme() {
          if (!window.structureColorMap) {
              window.structureColorMap = new Map();
              window.structureColorIndex = 0;
          }
          
          // æ¸…é™¤ç°æœ‰é¢œè‰²æ˜ å°„
          window.structureColorMap.clear();
          window.structureColorIndex = 0;
          
          // ä¸ºæ¯ä¸ªç»“æ„é‡æ–°åˆ†é…é¢œè‰²
          if (currentData && currentData.input && currentData.input.structures) {
              currentData.input.structures.forEach(structure => {
                  const newColor = getStructureColor(structure.id);
                  updateStructureColors(structure.id, newColor);
              });
          }
          
          // æ›´æ–°æ§åˆ¶é¢æ¿
          updateControlPanel();
      }

      // æ›´æ–°å‡ ä½•ä½“åˆ†æ®µæ•°
      function updateGeometrySegments(value) {
          const newValue = parseInt(value);
          currentSettings.geometrySegments = newValue;
          document.getElementById('segments-value').textContent = value;
          
          // å‘é€åˆ°æ‰©å±•ç«¯ä¿å­˜
          sendSettingsToExtension({ geometrySegments: newValue });
          
          // é‡æ–°ç”Ÿæˆæ‰€æœ‰å‡ ä½•ä½“ä»¥åº”ç”¨æ–°çš„åˆ†æ®µæ•°
          console.log('Updating geometry segments to:', value);
          
          if (currentData && currentData.input && currentData.input.structures) {
              // æ¸…é™¤ç°æœ‰å‡ ä½•ä½“
              structureGroups.forEach(group => {
                  scene.remove(group);
              });
              structureGroups.clear();
              constraintGroups.clear();
              
              // é‡æ–°åˆ›å»ºå‡ ä½•ä½“
              currentData.input.structures.forEach((structure) => {
                  createStructureVisualization(structure);
              });
              
              console.log('Regenerated all geometries with', value, 'segments');
          }
      }

      // æ›´æ–°ç»“æ„é€æ˜åº¦
      function updateOpacity(value) {
          const newValue = parseFloat(value);
          currentSettings.structureOpacity = newValue;
          document.getElementById('opacity-value').textContent = newValue.toFixed(2);
          
          // å‘é€åˆ°æ‰©å±•ç«¯ä¿å­˜
          sendSettingsToExtension({ structureOpacity: newValue });
          
          // åº”ç”¨åˆ°æ‰€æœ‰ç»“æ„æè´¨
          structureGroups.forEach(group => {
              group.traverse(child => {
                  if (child.material && !child.name.includes('wireframe')) {
                      child.material.opacity = currentSettings.structureOpacity;
                      child.material.transparent = true;
                  }
              });
          });
          
          console.log('Updated structure opacity to:', value);
      }

      // æ›´æ–°çº¦æŸé€æ˜åº¦
      function updateConstraintOpacity(value) {
          const newValue = parseFloat(value);
          currentSettings.constraintOpacity = newValue;
          document.getElementById('constraint-opacity-value').textContent = newValue.toFixed(2);
          
          // å‘é€åˆ°æ‰©å±•ç«¯ä¿å­˜
          sendSettingsToExtension({ constraintOpacity: newValue });
          
          // åº”ç”¨åˆ°æ‰€æœ‰çº¦æŸæè´¨ï¼ˆåŒ…æ‹¬ç®­å¤´ï¼‰
          constraintGroups.forEach(constraintMesh => {
              constraintMesh.traverse(child => {
                  if (child.material) {
                      child.material.opacity = currentSettings.constraintOpacity;
                      child.material.transparent = true;
                  }
              });
          });
          
          // åŒæ—¶æ›´æ–°ç»“æ„ç»„ä¸­çš„çº¦æŸç®­å¤´
          structureGroups.forEach(group => {
              group.traverse(child => {
                  if (child.name && (
                      child.name.includes('plane_arrow_') ||
                      child.name.includes('xygauss_arrow_')
                  ) && child.material) {
                      child.material.opacity = currentSettings.constraintOpacity;
                      child.material.transparent = true;
                  }
              });
          });
          
          console.log('Updated constraint opacity to:', value);
      }

      // æ›´æ–°èƒŒæ™¯é¢œè‰²
      function updateBackgroundColor(value) {
          currentSettings.backgroundColor = value;
          
          // å‘é€åˆ°æ‰©å±•ç«¯ä¿å­˜
          sendSettingsToExtension({ backgroundColor: value });
          
          if (scene) {
              scene.background = new THREE.Color(value);
          }
          
          // æ›´æ–°èƒŒæ™¯é¢„è®¾çš„æ´»åŠ¨çŠ¶æ€
          document.querySelectorAll('.color-preset').forEach(preset => {
              preset.classList.remove('active');
              if (preset.style.backgroundColor === value || 
                  preset.style.backgroundColor === new THREE.Color(value).getStyle()) {
                  preset.classList.add('active');
              }
          });
          
          console.log('Updated background color to:', value);
      }

      // æ›´æ–°ç¯å¢ƒå…‰å¼ºåº¦
      function updateAmbientLight(value) {
          const newValue = parseFloat(value);
          currentSettings.ambientLightIntensity = newValue;
          document.getElementById('ambient-light-value').textContent = value;
          
          // å‘é€åˆ°æ‰©å±•ç«¯ä¿å­˜
          sendSettingsToExtension({ ambientLightIntensity: newValue });
          
          if (ambientLight) {
              ambientLight.intensity = currentSettings.ambientLightIntensity;
          }
          
          console.log('Updated ambient light intensity to:', value);
      }

      // æ›´æ–°æ–¹å‘å…‰å¼ºåº¦
      function updateDirectionalLight(value) {
          const newValue = parseFloat(value);
          currentSettings.directionalLightIntensity = newValue;
          document.getElementById('directional-light-value').textContent = value;
          
          // å‘é€åˆ°æ‰©å±•ç«¯ä¿å­˜
          sendSettingsToExtension({ directionalLightIntensity: newValue });
          
          if (directionalLight) {
              directionalLight.intensity = currentSettings.directionalLightIntensity;
          }
          
          console.log('Updated directional light intensity to:', value);
      }

      // é‡ç½®æ‰€æœ‰è®¾ç½®
      function resetSettings() {
          const defaultSettings = {
              geometrySegments: 16,
              structureOpacity: 0.6,
              constraintOpacity: 0.3,
              backgroundColor: '#1e1e1e',
              ambientLightIntensity: 0.6,
              directionalLightIntensity: 0.8,
              colorTheme: 'default'
          };
          
          currentSettings = { ...defaultSettings };
          
          // å‘é€åˆ°æ‰©å±•ç«¯ä¿å­˜
          sendSettingsToExtension(defaultSettings);
          
          // æ›´æ–°UI
          updateSettingsUI();
          
          // åº”ç”¨è®¾ç½®
          applyAllSettings();
          
          console.log('Reset all settings to defaults');
      }

      // æ›´æ–°è®¾ç½®UIæ˜¾ç¤º
      function updateSettingsUI() {
          document.getElementById('segments-slider').value = currentSettings.geometrySegments;
          document.getElementById('segments-value').textContent = currentSettings.geometrySegments;
          
          document.getElementById('opacity-slider').value = currentSettings.structureOpacity;
          document.getElementById('opacity-value').textContent = currentSettings.structureOpacity.toFixed(2);
          
          document.getElementById('constraint-opacity-slider').value = currentSettings.constraintOpacity;
          document.getElementById('constraint-opacity-value').textContent = currentSettings.constraintOpacity.toFixed(2);
          
          document.getElementById('background-color').value = currentSettings.backgroundColor;
          
          document.getElementById('ambient-light-slider').value = currentSettings.ambientLightIntensity;
          document.getElementById('ambient-light-value').textContent = currentSettings.ambientLightIntensity.toFixed(1);
          
          document.getElementById('directional-light-slider').value = currentSettings.directionalLightIntensity;
          document.getElementById('directional-light-value').textContent = currentSettings.directionalLightIntensity.toFixed(1);
          
          // æ›´æ–°ä¸»é¢˜é€‰æ‹©
          document.querySelectorAll('.theme-option').forEach(option => {
              option.classList.remove('active');
          });
          const activeThemeIndex = Object.keys(colorThemes).indexOf(currentSettings.colorTheme);
          if (activeThemeIndex >= 0) {
              document.querySelectorAll('.theme-option')[activeThemeIndex]?.classList.add('active');
          }
      }

      // åº”ç”¨æ‰€æœ‰è®¾ç½®
      function applyAllSettings() {
          updateGeometrySegments(currentSettings.geometrySegments);
          updateOpacity(currentSettings.structureOpacity);
          updateConstraintOpacity(currentSettings.constraintOpacity);
          updateBackgroundColor(currentSettings.backgroundColor);
          updateAmbientLight(currentSettings.ambientLightIntensity);
          updateDirectionalLight(currentSettings.directionalLightIntensity);
          applyColorTheme();
      }

      // ä¿å­˜è®¾ç½®ï¼ˆç°åœ¨è®¾ç½®ä¼šè‡ªåŠ¨åŒæ­¥åˆ°VS Codeé…ç½®ï¼‰
      function saveSettings() {
          // æ˜¾ç¤ºæç¤º - è®¾ç½®å·²ç»è‡ªåŠ¨åŒæ­¥åˆ° VS Code
          const originalText = event.target.textContent;
          event.target.textContent = 'âœ… å·²åŒæ­¥';
          event.target.style.background = '#28a745';
          setTimeout(() => {
              event.target.textContent = originalText;
              event.target.style.background = '';
          }, 2000);
          
          console.log('Settings are automatically synced to VS Code configuration');
      }

      // åŠ è½½è®¾ç½®ï¼ˆç°åœ¨è®¾ç½®ä»VS Codeé…ç½®è‡ªåŠ¨åŠ è½½ï¼‰
      function loadSettings() {
          // æ˜¾ç¤ºæç¤º - è®¾ç½®ä» VS Code é…ç½®è‡ªåŠ¨åŠ è½½
          const originalText = event.target.textContent;
          event.target.textContent = 'âœ… å·²åŒæ­¥';
          event.target.style.background = '#28a745';
          setTimeout(() => {
              event.target.textContent = originalText;
              event.target.style.background = '';
          }, 2000);
          
          console.log('Settings are automatically loaded from VS Code configuration');
      }



      // ä¿®æ”¹ç°æœ‰çš„ getStructureColor å‡½æ•°ä»¥æ”¯æŒä¸»é¢˜
      function getStructureColor(structureId) {
          const currentTheme = colorThemes[currentSettings.colorTheme] || colorThemes.default;
          const colors = currentTheme.colors;

          // ä¸ºæ¯ä¸ªç»“æ„åˆ†é…ä¸€ä¸ªå›ºå®šçš„é¢œè‰²ç´¢å¼•
          if (!window.structureColorMap) {
              window.structureColorMap = new Map();
              window.structureColorIndex = 0;
          }

          if (!window.structureColorMap.has(structureId)) {
              window.structureColorMap.set(structureId, colors[window.structureColorIndex % colors.length]);
              window.structureColorIndex++;
          }

          return window.structureColorMap.get(structureId);
      }

      // ========== æ§åˆ¶é¢æ¿æŠ˜å å’Œæ‹–æ‹½åŠŸèƒ½ ==========

      // åˆ‡æ¢æ•´ä¸ªæ§åˆ¶é¢æ¿çš„æŠ˜å çŠ¶æ€
      function toggleControlsPanel() {
          const controls = document.getElementById('controls');
          const toggleIcon = document.getElementById('controls-toggle-icon');
          
          controlPanelState.collapsed = !controlPanelState.collapsed;
          
          if (controlPanelState.collapsed) {
              controls.classList.add('collapsed');
              toggleIcon.textContent = '+';
          } else {
              controls.classList.remove('collapsed');
              toggleIcon.textContent = 'âˆ’';
          }
          
          saveControlPanelState();
          console.log('Controls panel toggled:', controlPanelState.collapsed ? 'collapsed' : 'expanded');
      }

      // åˆ‡æ¢æ§åˆ¶ç»„çš„æŠ˜å çŠ¶æ€
      function toggleControlGroup(headerElement) {
          const controlGroup = headerElement.parentElement;
          const toggleButton = headerElement.querySelector('.control-group-toggle span');
          const h3Text = headerElement.querySelector('h3').textContent;
          
          // ç¡®å®šç»„çš„æ ‡è¯†ç¬¦
          let groupKey = '';
          if (h3Text.includes('View Controls')) {
              groupKey = 'view-controls';
          } else if (h3Text.includes('Structures')) {
              groupKey = 'structures-constraints';
          } else if (h3Text.includes('Statistics')) {
              groupKey = 'statistics';
          }
          
          // åˆ‡æ¢çŠ¶æ€
          controlPanelState.groupStates[groupKey] = !controlPanelState.groupStates[groupKey];
          const isCollapsed = controlPanelState.groupStates[groupKey];
          
          if (isCollapsed) {
              controlGroup.classList.add('collapsed');
              toggleButton.textContent = '+';
          } else {
              controlGroup.classList.remove('collapsed');
              toggleButton.textContent = 'âˆ’';
          }
          
          saveControlPanelState();
          console.log(`Control group ${groupKey} toggled:`, isCollapsed ? 'collapsed' : 'expanded');
      }

      // ä¿å­˜æ§åˆ¶é¢æ¿çŠ¶æ€åˆ°localStorage
      function saveControlPanelState() {
          try {
              localStorage.setItem('packmolControlPanelState', JSON.stringify(controlPanelState));
          } catch (error) {
              console.warn('Failed to save control panel state:', error);
          }
      }

      // åŠ è½½æ§åˆ¶é¢æ¿çŠ¶æ€
      function loadControlPanelState() {
          try {
              const saved = localStorage.getItem('packmolControlPanelState');
              if (saved) {
                  controlPanelState = { ...controlPanelState, ...JSON.parse(saved) };
                  applyControlPanelState();
              }
          } catch (error) {
              console.warn('Failed to load control panel state:', error);
          }
      }

      // åº”ç”¨æ§åˆ¶é¢æ¿çŠ¶æ€
      function applyControlPanelState() {
          const controls = document.getElementById('controls');
          const toggleIcon = document.getElementById('controls-toggle-icon');
          
          // åº”ç”¨ä½ç½®
          controls.style.left = controlPanelState.position.x + 'px';
          controls.style.top = controlPanelState.position.y + 'px';
          
          // åº”ç”¨æ•´ä½“æŠ˜å çŠ¶æ€
          if (controlPanelState.collapsed) {
              controls.classList.add('collapsed');
              toggleIcon.textContent = '+';
          } else {
              controls.classList.remove('collapsed');
              toggleIcon.textContent = 'âˆ’';
          }
          
          // åº”ç”¨å„ç»„çš„æŠ˜å çŠ¶æ€
          setTimeout(() => {
              // ç­‰å¾…DOMå®Œå…¨æ¸²æŸ“åå†åº”ç”¨ç»„çŠ¶æ€
              const controlGroups = document.querySelectorAll('.control-group');
              controlGroups.forEach((group, index) => {
                  const keys = ['view-controls', 'structures-constraints', 'statistics'];
                  const groupKey = keys[index];
                  const isCollapsed = controlPanelState.groupStates[groupKey];
                  const toggleButton = group.querySelector('.control-group-toggle span');
                  
                  if (isCollapsed && toggleButton) {
                      group.classList.add('collapsed');
                      toggleButton.textContent = '+';
                  } else if (toggleButton) {
                      group.classList.remove('collapsed');
                      toggleButton.textContent = 'âˆ’';
                  }
              });
          }, 100);
      }

      // åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½
      function initializeControlsDrag() {
          const controlsHeader = document.getElementById('controls-header');
          const controls = document.getElementById('controls');
          
          if (!controlsHeader || !controls) {
              console.warn('Controls header or controls panel not found');
              return;
          }
          
          // é¼ æ ‡æŒ‰ä¸‹å¼€å§‹æ‹–æ‹½
          controlsHeader.addEventListener('mousedown', (e) => {
              if (e.target.classList.contains('controls-toggle') || 
                  e.target.closest('.controls-toggle')) {
                  return; // ä¸åœ¨åˆ‡æ¢æŒ‰é’®ä¸Šå¼€å§‹æ‹–æ‹½
              }
              
              isDragging = true;
              controls.classList.add('dragging');
              
              const rect = controls.getBoundingClientRect();
              dragOffsetX = e.clientX - rect.left;
              dragOffsetY = e.clientY - rect.top;
              
              // é˜»æ­¢æ–‡æœ¬é€‰æ‹©
              e.preventDefault();
              
              console.log('Started dragging controls panel');
          });
          
          // é¼ æ ‡ç§»åŠ¨
          document.addEventListener('mousemove', (e) => {
              if (!isDragging) return;
              
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              const controlsRect = controls.getBoundingClientRect();
              
              // è®¡ç®—æ–°ä½ç½®ï¼Œç¡®ä¿ä¸è¶…å‡ºè§†çª—è¾¹ç•Œ
              let newX = e.clientX - dragOffsetX;
              let newY = e.clientY - dragOffsetY;
              
              // è¾¹ç•Œæ£€æŸ¥
              newX = Math.max(0, Math.min(newX, viewportWidth - controlsRect.width));
              newY = Math.max(0, Math.min(newY, viewportHeight - controlsRect.height));
              
              controls.style.left = newX + 'px';
              controls.style.top = newY + 'px';
              
              // æ›´æ–°çŠ¶æ€
              controlPanelState.position.x = newX;
              controlPanelState.position.y = newY;
          });
          
          // é¼ æ ‡é‡Šæ”¾ç»“æŸæ‹–æ‹½
          document.addEventListener('mouseup', () => {
              if (isDragging) {
                  isDragging = false;
                  controls.classList.remove('dragging');
                  saveControlPanelState();
                  console.log('Ended dragging controls panel at:', controlPanelState.position);
              }
          });
          
          // è§¦æ‘¸è®¾å¤‡æ”¯æŒ
          controlsHeader.addEventListener('touchstart', (e) => {
              if (e.target.classList.contains('controls-toggle') || 
                  e.target.closest('.controls-toggle')) {
                  return;
              }
              
              const touch = e.touches[0];
              isDragging = true;
              controls.classList.add('dragging');
              
              const rect = controls.getBoundingClientRect();
              dragOffsetX = touch.clientX - rect.left;
              dragOffsetY = touch.clientY - rect.top;
              
              e.preventDefault();
          });
          
          document.addEventListener('touchmove', (e) => {
              if (!isDragging) return;
              
              const touch = e.touches[0];
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              const controlsRect = controls.getBoundingClientRect();
              
              let newX = touch.clientX - dragOffsetX;
              let newY = touch.clientY - dragOffsetY;
              
              newX = Math.max(0, Math.min(newX, viewportWidth - controlsRect.width));
              newY = Math.max(0, Math.min(newY, viewportHeight - controlsRect.height));
              
              controls.style.left = newX + 'px';
              controls.style.top = newY + 'px';
              
              controlPanelState.position.x = newX;
              controlPanelState.position.y = newY;
              
              e.preventDefault();
          });
          
          document.addEventListener('touchend', () => {
              if (isDragging) {
                  isDragging = false;
                  controls.classList.remove('dragging');
                  saveControlPanelState();
              }
          });
          
          console.log('âœ… Controls drag functionality initialized');
      }

      // å¯åŠ¨åˆå§‹åŒ–
      console.log('ğŸ Starting initialization sequence...');

      // ç«‹å³æµ‹è¯•è¿æ¥
      testVSCodeConnection();

      // æ£€æŸ¥ DOM çŠ¶æ€å¹¶å¼€å§‹åˆå§‹åŒ–
      function startInitialization() {
          console.log('ğŸ“‹ DOM ready, starting Three.js check...');
          // çŸ­æš‚å»¶è¿Ÿä»¥ç¡®ä¿è„šæœ¬æ ‡ç­¾æœ‰æ—¶é—´åŠ è½½
          setTimeout(() => {
              checkThreeJS();
          }, 100);
      }

      // ç­‰å¾… DOM åŠ è½½
      if (document.readyState === 'loading') {
          console.log('â³ DOM still loading, waiting for DOMContentLoaded...');
          document.addEventListener('DOMContentLoaded', startInitialization);
      } else {
          console.log('âœ… DOM already loaded');
          startInitialization();
      }

      // å¤‡ç”¨æ–¹æ¡ˆï¼šå¦‚æœåœ¨ 5 ç§’å†…è¿˜æ²¡æœ‰åˆå§‹åŒ–ï¼Œå¼ºåˆ¶å‘é€ ready æ¶ˆæ¯
      setTimeout(() => {
          if (!isThreeJSReady && vscode) {
              console.log('âš ï¸ Fallback: Sending ready message after timeout');
              sendReadyMessage();
          }
      }, 5000);
    </script>

    <!-- åœ¨æœ€åæ·»åŠ  Three.js è„šæœ¬ï¼Œç¡®ä¿ DOM å…ˆåŠ è½½ -->
    <script
      src="${threeJsUri}"
      onerror="console.error('âŒ Failed to load Three.js from CDN'); document.getElementById('loading').innerHTML = 'Error: Failed to load Three.js';"
      onload="console.log('âœ… Three.js script loaded from CDN');"
    ></script>
  </body>
</html>
